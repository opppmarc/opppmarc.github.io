<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>16信管答辩简记</title>
    <url>/2020/05/16/16Reply/</url>
    <content><![CDATA[<p>简要听了下16级师兄师姐的线上毕业答辩会议，可以说是水平差异比较大，但于学弟而言一场答辩的旁听也大致让我了解了大概的流程并有吸取到一些经验吧，总得感受就是准备一定要充分，只有充足的准备才能让你的项目真真正正落地，或者让论文研究更加完善。</p>
<a id="more"></a>
<p>以下是部分答辩内容，不代表全部。</p>
<h3 id="留学信息检索系统"><a href="#留学信息检索系统" class="headerlink" title="留学信息检索系统"></a>留学信息检索系统</h3><p>1.选题背景 2.现有检索系统现状 3.研究意义 4.技术架构 5.成果 6.总结/优点/不足 7.致谢</p>
<ul>
<li>Q:数据比较简单，如果出现复杂数据时如何处理 </li>
<li>Q:系统中的分类有无与信息结合，是存在自动化分类还是需要人工进行分类 </li>
<li>A:有用到phyton (应该是无自动化)</li>
</ul>
<h3 id="基于SSM与Redis的技术类主题社区的设计与实现-技术类主题社区网站"><a href="#基于SSM与Redis的技术类主题社区的设计与实现-技术类主题社区网站" class="headerlink" title="基于SSM与Redis的技术类主题社区的设计与实现(技术类主题社区网站)"></a>基于SSM与Redis的技术类主题社区的设计与实现(技术类主题社区网站)</h3><p>1.需求及技术选型<br>2.功能分析：点赞/用户私信/多实体评论中心/页面内容展示/账号安全保障<br>4.系统实现<br>5.压力测试：多线程组并发测试<br>6.结论： 创新之处/存在问题/后续研究方向</p>
<ul>
<li>Q:能否通过实际应用</li>
<li>Q:技术类社区和普通社区有什么不同，在网站技术上怎么体现它的不同</li>
</ul>
<h3 id="信管专业本科生就业状况的调查与分析"><a href="#信管专业本科生就业状况的调查与分析" class="headerlink" title="信管专业本科生就业状况的调查与分析"></a>信管专业本科生就业状况的调查与分析</h3><p>1.论文绪论<br>采用问卷调查法、文献调查法调查相关学生就业状况，针对具体问题提出措施<br>2.研究方法 3.调查阐述 4.研究成果 5.总结展望 (比较水,分析不够深入) 最后致谢</p>
<ul>
<li>Q:论文中的分析总结比较简短？最好能体现基于现在数据所采用的数理分析方法、统计方法的重要作用，而不是着重展示大量数据</li>
<li>Q:数据样本数量有多大？(有点少)数据样本获取之后是怎么对数据进行处理的？ </li>
<li>A:采用交叉分析法 </li>
<li>Q:能具体讲一下吗 </li>
<li>Q:有无借助其他数据工具进行辅助分析还是单纯是自己分析的数据</li>
</ul>
<h3 id="知识管理与企业核心竞争力的培养研究"><a href="#知识管理与企业核心竞争力的培养研究" class="headerlink" title="知识管理与企业核心竞争力的培养研究"></a>知识管理与企业核心竞争力的培养研究</h3><p>1.选题背景 2.研究意义 3.研究方法 文献研究法和案例分析法 4.案例分析 (分析内容偏少) 5.论文总结 (缺乏致谢)</p>
<ul>
<li>Q:论文中能体现专业素养或技术的亮点在哪？</li>
<li>A:回答模棱两可</li>
<li>Q:为什么选择所调查的三所公司？ </li>
<li>A:公司规模大..在行业有代表性..有充足的文献可供参考</li>
<li>Q:对论文这块的研究，你得出什么具体的成果了吗？</li>
<li>A:答案模糊 显然没有自己独到的成果</li>
</ul>
<h3 id="出租屋管理信息系统的设计与实现"><a href="#出租屋管理信息系统的设计与实现" class="headerlink" title="出租屋管理信息系统的设计与实现"></a>出租屋管理信息系统的设计与实现</h3><p>1.背景 2.系统分析 从软件的使用主体来进行分析需求 3.主要功能模块 4.实现方法 5.总结 (缺乏致谢)</p>
<ul>
<li>Q:实现了吗各个模块？ </li>
<li>A:没有全实现，只针对业务进行了实现</li>
<li>Q:基本功能是有了，但是还是有点简单</li>
</ul>
<h3 id="项目管理对公司绩效的影响——以威拓公司为例"><a href="#项目管理对公司绩效的影响——以威拓公司为例" class="headerlink" title="项目管理对公司绩效的影响——以威拓公司为例"></a>项目管理对公司绩效的影响——以威拓公司为例</h3><p>1.研究背景及意义 2.项目管理现状 3.项目管理对公司绩效的影响:管理制度/胜任力/资源管理/客户管理 4.项目管理对威拓公司绩效的影响(具体案例分析) 6.总结 </p>
<ul>
<li>缺乏正反方面的例子</li>
</ul>
<h3 id="基于4GL的中小型制造业ERP采购管理系统的设计与实现"><a href="#基于4GL的中小型制造业ERP采购管理系统的设计与实现" class="headerlink" title="基于4GL的中小型制造业ERP采购管理系统的设计与实现"></a>基于4GL的中小型制造业ERP采购管理系统的设计与实现</h3><p>1.背景 2.业务流程 流程图 3.系统设计 系统组成模块/模块功能  其中MRP功能没有实现 4.实现方法 开发语言Genero FGL/Oracle数据库(阐述了为什么要使用这样的技术搭配)  实现后的运行页面展示  接口功能未实现 5.结论 6.致谢</p>
<ul>
<li>Q:这个erp系统是企业在用的吗？ </li>
<li>A:不是，是企业提供的用来练习的 </li>
<li>Q:这个系统是自己做的吗？ </li>
<li>A:是公司的框架，其他自己开发</li>
</ul>
]]></content>
      <categories>
        <category>信息管理与信息系统</category>
      </categories>
      <tags>
        <tag>信管</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo+GithubBlog搭建</title>
    <url>/2020/05/17/BlogBuding/</url>
    <content><![CDATA[<p>基于开源框架搭建博客，可以直接在<em>github page</em>上平台上托管自己的博客。Hexo是高效的静态网站生成框架，它基于Node.js，快速、简单且功能强大。通过Hexo，可以直接使用Markdown语法来撰写博客，但在这之前需要做好一些准备工作…</p>
<a id="more"></a>
<p><a href="https://sunhwee.com/posts/6e8839eb.html#toc-heading-14" target="_blank" rel="noopener">传送门</a> 参考自洪卫的博客，以下仅部分会展开详细说明，保姆级教程请点传送门跳转。:P</p>
<p>这篇文章主要记录如何进行hexo的初级搭建，将hexo部署到github page上，以及个人域名的绑定、文章的发布。</p>
<h2 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h2><ul>
<li>安装 Git</li>
<li>安装 Node.js</li>
<li>安装 Hexo</li>
<li>在Github创建个人仓库</li>
<li>生成SSH添加到GitHub</li>
<li>将hexo部署到github</li>
<li>设置个人域名</li>
<li>发布文章</li>
</ul>
<h2 id="1-安装Git"><a href="#1-安装Git" class="headerlink" title="1.安装Git"></a>1.安装Git</h2><p>为了把本地网页文件上传到github，需要用到Git。Git是目前世界上先进的分布式版本控制系统，可以有效、高速处理从小到非常大的项目版本管理。     </p>
<p>windows系统用户直接到git官网下载即可，网上教程都说在安装过程最后一步添加路径时要选择<em>Use GIt form the Windows Command Prompt</em>(为了能直接在命令提示符里打开git)，但是我在安装时在这一步中并没有看到该选项，就选择了<em>Use Git form the VS Code</em>，原本以为是要在vscode里打开git，后来发现在文件目录下右键就能看到Git bush的选项了。</p>
<h2 id="2-安装node-js"><a href="#2-安装node-js" class="headerlink" title="2.安装node.js"></a>2.安装node.js</h2><p>Hexo是基于node.js编写的，所以需要安装node.js和里面的npm工具。<br>windows系统下载好Node.js后，按<kbd>Win</kbd>+<kbd>R</kbd>打开命令提示符，输入 node -v 和 npm -v，如果出现版本号就安装成功了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node -v  </span><br><span class="line">11.1      </span><br><span class="line"></span><br><span class="line">npm -v  </span><br><span class="line">5.6.0</span><br></pre></td></tr></table></figure>

<p>继续添加国内镜像源(这里用阿里的国内镜像加速，不用梯子)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<h2 id="3-安装Hexo"><a href="#3-安装Hexo" class="headerlink" title="3.安装Hexo"></a>3.安装Hexo</h2><p>创建一个文件夹来存放自己的博客文件，例如创建了<em>MyBlog<em>，就在</em>D：\MyBlog</em> 目录下直接右键gitbash打开  </p>
<p>先安装hexo</p>
<pre><code>npm install -g hexo-cli </code></pre><p>安装完后验证是否安装成功</p>
<pre><code>hexo -v </code></pre><p>验证成功后会输出版本信息   </p>
<pre><code>hexo-cli: 3.1.0  
os: Windows_NT 10.0.18363 win32 x64  
http_parser: 2.8.0  
node: 9.11.1  
v8: 6.2.414.46-node.23  
uv: 1.19.2  
zlib: 1.2.11  
ares: 1.13.0  
modules: 59  
nghttp2: 1.29.0  
napi: 3  
openssl: 1.0.2o  
icu: 61.1  
unicode: 10.0  
cldr: 33.0  
tz: 2018c</code></pre><p>然后初始化Hexo,初始化文件夹MyBlog,文件夹名也可以是你自己命名的</p>
<pre><code>hexo init MyBlog</code></pre><p>然后cd到文件夹安装组件  </p>
<pre><code>cd MyBlog  
npm install</code></pre><p>生成静态网页并在本地服务器打开</p>
<pre><code>hexo generate //简写：hexo g  
hexo server    //简写：hexo s</code></pre><h2 id="4-注册Github账户并创建个人仓库"><a href="#4-注册Github账户并创建个人仓库" class="headerlink" title="4.注册Github账户并创建个人仓库"></a>4.注册Github账户并创建个人仓库</h2><p>github账户就不说了，点击首页右上角加号新建一个项目仓库<em>New repositroy</em>,要创建一个和你用户名相同的仓库，后面加.<a href="http://github.io，只有这样，将来要部署到GitHub" target="_blank" rel="noopener">http://github.io，只有这样，将来要部署到GitHub</a> page的时候，才会被识别，也就是<a href="http://xxxx.github.io，其中xxx就是你注册GitHub的用户名。" target="_blank" rel="noopener">http://xxxx.github.io，其中xxx就是你注册GitHub的用户名。</a></p>
<p>如下图所示，项目名字和用户名一致，同时后面加<code>.github.io</code>后缀，<code>README</code>初始化勾选上。<br><img src="https://s1.ax1x.com/2020/05/17/Y2rcIH.png" alt="Y2rcIH.png"></p>
<h2 id="5-生成SSH添加到GitHub"><a href="#5-生成SSH添加到GitHub" class="headerlink" title="5.生成SSH添加到GitHub"></a>5.生成SSH添加到GitHub</h2><p>在博客根目录右键打开<code>git bash</code>，输入以下命令:  </p>
<pre><code>git config --global user.name &quot;yourname&quot;
git config --global user.email &quot;youremail&quot;</code></pre><p>youname指GitHub用户名，youremail指Github邮箱。  </p>
<p>输入命令核对：  </p>
<pre><code>git config user.name
git config user.email</code></pre><blockquote>
<p>ssh就是秘钥，创建好后会输出私钥和公钥，链接Github账户后，把公钥放在Github上，就可以根据公钥匹配本地电脑的私钥，然后通过git上传数据到github上。</p>
</blockquote>
<p>创建<code>SSH</code>,一直回车</p>
<pre><code>ssh-keygen -t rsa -C &quot;youremail&quot;</code></pre><p>系统会告诉你生成了<code>.ssh</code>的文件夹，在该文件夹目录下<code>git bash</code>输入</p>
<pre><code>cat ~/.ssh/id_rsa.pub</code></pre><p>复制输出的内容，打开Github，在头像下面点击<code>settings</code>，再点击<code>SSH and GPG keys</code>，新建一个<code>SSH</code>，名字随便取一个都可以，把刚才复制的id_rsa.pub信息复制进去。如图：</p>
<p><img src="https://s1.ax1x.com/2020/05/17/Y2rcIH.png" alt="Y2rcIH.png"></p>
<p>回到博客根目录，<code>git bash</code>输入：</p>
<pre><code>ssh -T git@github.com</code></pre><p><img src="https://s1.ax1x.com/2020/05/17/Y2r6de.png" alt="Y2r6de.png"><br>系统输出的信息中包含你的用户名就成功了。</p>
<h2 id="6-将hexo部署到GitHub"><a href="#6-将hexo部署到GitHub" class="headerlink" title="6.将hexo部署到GitHub"></a>6.将hexo部署到GitHub</h2><p>打开博客根目录下的<code>_config.yml</code>文件，这是博客的配置文件，修改最后一行的配置：  </p>
<pre><code>deploy:
type: git
repository: https://github.com/opppmarc/opppmarc.github.io  //这里是自己的github项目地址
branch: master</code></pre><p>根目录右键<code>git bash</code>安装<code>deploy-git</code>：  </p>
<pre><code>npm install hexo-deployer-git --save</code></pre><p>然后  </p>
<pre><code>hexo clean      //清除之前生成的东西
hexo generate   //生成静态文章
hexo deploy     //部署文章</code></pre><blockquote>
<p>过程中可能会要求输入Github账户信息</p>
</blockquote>
<p>系统反馈<code>NFO Deploy done: git</code>则部署成功了。</p>
<h2 id="7-设置个人域名"><a href="#7-设置个人域名" class="headerlink" title="7.设置个人域名"></a>7.设置个人域名</h2><p>这一块需要花钱购置域名，详情参见传送门原博。</p>
<h2 id="8-写文章、发布文章"><a href="#8-写文章、发布文章" class="headerlink" title="8.写文章、发布文章"></a>8.写文章、发布文章</h2><p>博客根目录打开<code>git bash</code>，安装一个拓展：</p>
<pre><code>npm i hexo-deployer-git</code></pre><p>新建一篇文章：  </p>
<pre><code>hexo new post &quot;article title&quot;       //引号里是文章标题</code></pre><p>在<code>\source\_post</code>目录下会发现一个新的md文件， 然后编辑内容即可。  </p>
<p>编辑好文章内容后，根目录下打开<code>git bash</code>，依次输入：</p>
<pre><code>hexo clean      //简写 hexo c 清除缓存
hexo generate   //简写 hexo g 生成静态文章
hexo server     //简写 hexo s 本地预览
hexo deploy   //简写 hexo d 上传部署</code></pre>]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>CSharp6新特性</title>
    <url>/2020/11/26/CSharp6%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h2 id="有关C-6新特性的简单总结"><a href="#有关C-6新特性的简单总结" class="headerlink" title="有关C#6新特性的简单总结"></a>有关C#6新特性的简单总结</h2><p>转载自Zoe_yan <a href="https://www.cnblogs.com/zoe-yan/p/10276270.html" target="_blank" rel="noopener">《C# 6新特性简单总结》</a></p>
<p>最近在看《C#高级编程 C# 6&amp;.NET Core 1.0》，会做一些读书笔记，也算对知识的总结与沉淀了。  </p>
<a id="more"></a>

<h3 id="1-静态的using声明"><a href="#1-静态的using声明" class="headerlink" title="1. 静态的using声明"></a>1. 静态的using声明</h3><p>静态的using声明允许调用静态方法时不使用类名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; C# 5</span><br><span class="line">using System;</span><br><span class="line"></span><br><span class="line">Console.WriteLine(&quot;C# 5&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; C# 6</span><br><span class="line">using static System.Console;</span><br><span class="line"></span><br><span class="line">WriteLine(&quot;C# 6&quot;);</span><br></pre></td></tr></table></figure>


<h3 id="2-表达式体方法"><a href="#2-表达式体方法" class="headerlink" title="2.表达式体方法"></a>2.表达式体方法</h3><p>表达式体方法只包含一个可以用Lambda语法编写的语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; C# 5</span><br><span class="line">public bool IsSquare(Rectangle rect)</span><br><span class="line">&#123;</span><br><span class="line">     return rect.Width &#x3D;&#x3D; rect.Height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; C# 6</span><br><span class="line">public bool IsSquare(Rectangle rect) &#x3D;&gt; rect.Width &#x3D;&#x3D; rect.Height;</span><br></pre></td></tr></table></figure>


<h3 id="3-表达式体属性"><a href="#3-表达式体属性" class="headerlink" title="3.表达式体属性"></a>3.表达式体属性</h3><p>与表达式体方法类似，只有get存储器的单行属性可以用Lambda语法编写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; C# 5</span><br><span class="line">public string FullName</span><br><span class="line">&#123;</span><br><span class="line">    get</span><br><span class="line">    &#123;</span><br><span class="line">        return FirstName + &quot; &quot; + LastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; C# 6</span><br><span class="line">public string FullName &#x3D;&gt; FirstName + &quot; &quot; + LastName;</span><br></pre></td></tr></table></figure>

<h3 id="4-自动实现的属性初始化器"><a href="#4-自动实现的属性初始化器" class="headerlink" title="4.自动实现的属性初始化器"></a>4.自动实现的属性初始化器</h3><p>自动实现的属性可以用属性初始化器来初始化：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; C# 5</span><br><span class="line">public class Person</span><br><span class="line">&#123;</span><br><span class="line">    public Person()</span><br><span class="line">    &#123;</span><br><span class="line">        Age &#x3D; 24;</span><br><span class="line">    &#125;</span><br><span class="line">    public int Age &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; C# 6</span><br><span class="line">public class Person</span><br><span class="line">&#123;</span><br><span class="line">    public int Age &#123; get; set; &#125; &#x3D; 24;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="5-只读的自动属性"><a href="#5-只读的自动属性" class="headerlink" title="5.只读的自动属性"></a>5.只读的自动属性</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; C# 5</span><br><span class="line">private readonly int _bookId;</span><br><span class="line">public BookId</span><br><span class="line">&#123;</span><br><span class="line">    get</span><br><span class="line">    &#123;</span><br><span class="line">        return _bookId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; C# 6</span><br><span class="line">private readonly int _bookId;</span><br><span class="line">public BookId &#123; get; &#125;</span><br></pre></td></tr></table></figure>


<h3 id="6-nameof运算符"><a href="#6-nameof运算符" class="headerlink" title="6.nameof运算符"></a>6.nameof运算符</h3><p>使用新的nameof运算符，可以访问字段名、属性名、方法名和类型名。这样，在重构时就不会遗漏名称的改变：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; C# 5</span><br><span class="line">public void Method(object o)</span><br><span class="line">&#123;</span><br><span class="line">    if(o &#x3D;&#x3D; null)</span><br><span class="line">    &#123;</span><br><span class="line">        throw new ArgumentNullException(&quot;o&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; C# 6</span><br><span class="line">public void Method(object o)</span><br><span class="line">&#123;</span><br><span class="line">    if(o &#x3D;&#x3D; null)</span><br><span class="line">     &#123;</span><br><span class="line">        throw new ArgumentNullException(nameof(o));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="7-空值传播运算符"><a href="#7-空值传播运算符" class="headerlink" title="7.空值传播运算符"></a>7.空值传播运算符</h3><p>空值传播运算符简化了空值的检查：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; C# 5</span><br><span class="line">int? age &#x3D; p &#x3D;&#x3D; null ? null : p.Age;</span><br><span class="line">&#x2F;&#x2F; C# 6</span><br><span class="line">int? age &#x3D; p?.Age;</span><br></pre></td></tr></table></figure>

<h3 id="8-字符串插值"><a href="#8-字符串插值" class="headerlink" title="8.字符串插值"></a>8.字符串插值</h3><p>字符串插值删除了对string.Format的调用，它不在字符串中使用编号的格式占位符，占位符可以包含表达式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; C# 5</span><br><span class="line">public override string ToString()</span><br><span class="line">&#123;</span><br><span class="line">    return string.Format(&quot;&#123;0&#125;,&#123;1&#125;&quot;, Title, Publisher);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; C# 6</span><br><span class="line">public override string ToString() &#x3D;&gt; $&quot;&#123;Title&#125;&#123;Publisher&#125;&quot;;</span><br></pre></td></tr></table></figure>

<h3 id="9-字典初始化"><a href="#9-字典初始化" class="headerlink" title="9.字典初始化"></a>9.字典初始化</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; C# 5</span><br><span class="line">var dic &#x3D; new Dictionary&lt;int, string&gt;();</span><br><span class="line">dic.Add(3, &quot;three&quot;);</span><br><span class="line">dic.Add(7, &quot;seven&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; C# 6</span><br><span class="line">var dic &#x3D; new Dictionary&lt;int, string&gt;()</span><br><span class="line">&#123;</span><br><span class="line">    [3] &#x3D; &quot;three&quot;,</span><br><span class="line">    [7] &#x3D; &quot;seven&quot;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="10-异常过滤器"><a href="#10-异常过滤器" class="headerlink" title="10.异常过滤器"></a>10.异常过滤器</h3><p>异常过滤器允许在捕获异常之前过滤它们：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; C# 5</span><br><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">      &#x2F;&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">catch (MyException ex)</span><br><span class="line">&#123;</span><br><span class="line">    if (ex.ErrorCode !&#x3D; 405) throw;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; C# 6</span><br><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">      &#x2F;&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">catch (MyException ex) when (ex.ErrorCode &#x3D;&#x3D; 405)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>11.catch中的await<br>await现在可以在catch子句中使用，C# 5需要一种变通方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; C# 5</span><br><span class="line">bool hasError &#x3D; false;</span><br><span class="line">string errorMsg &#x3D; null;</span><br><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">catch (MyException ex)</span><br><span class="line">&#123;</span><br><span class="line">    hasError &#x3D; true;</span><br><span class="line">    errorMsg &#x3D; ex.Message;</span><br><span class="line">&#125;</span><br><span class="line">if (hasError)</span><br><span class="line">&#123;</span><br><span class="line">    await new MessageDialog().ShowAsync(errorMsg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; C# 6</span><br><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">catch (MyException ex)</span><br><span class="line">&#123;</span><br><span class="line">    await new MessageDialog().ShowAsync(ex.Message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>C#中关键字ref与out的区别</title>
    <url>/2020/10/14/C-%E4%B8%AD%E5%85%B3%E9%94%AE%E5%AD%97ref%E4%B8%8Eout%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="C-中关键字ref与out的区别"><a href="#C-中关键字ref与out的区别" class="headerlink" title="C#中关键字ref与out的区别"></a>C#中关键字ref与out的区别</h2><p>C#中通过ref与Out关键字可以使参数按照引用来传递，通过引用（ref）和输出（out）向方法传递参数。</p>
<a id="more"></a>

<h4 id="区别1：out参数会清空对内存地址的引用和指向-使用前必需重新赋值，而Ref不需要。"><a href="#区别1：out参数会清空对内存地址的引用和指向-使用前必需重新赋值，而Ref不需要。" class="headerlink" title="区别1：out参数会清空对内存地址的引用和指向, 使用前必需重新赋值，而Ref不需要。"></a>区别1：out参数会清空对内存地址的引用和指向, 使用前必需重新赋值，而Ref不需要。</h4><p><img src="https://s1.ax1x.com/2020/10/14/0IrSxI.png" alt="0IrSxI.png"></p>
<p>像下面的代码，refTest方法输出的就是原来的值，但outTest方法输出的是后来重新赋值的值，而不是原来的值。</p>
<blockquote>
<p>MSDN中对out关键字的定义：<br>out 关键字会导致参数通过引用来传递。这与 ref 关键字类似，不同之处在于 ref 要求变量必须在传递之前进行初始化。若要使用 out 参数，方法定义和调用方法都必须显式使用 out 关键字。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">    string str &#x3D; &quot;Hello&quot;;</span><br><span class="line">    RefTest(ref str);</span><br><span class="line">    outTest(out str);</span><br><span class="line"></span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void outTest(out string str)</span><br><span class="line">&#123;</span><br><span class="line">    str &#x3D; &quot;Bye&quot;;</span><br><span class="line">    Console.WriteLine(str);     &#x2F;&#x2F;output: Bye</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void RefTest(ref string str)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(str);     &#x2F;&#x2F;output: Hello</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="区别2：ref参数在使用前必需初始化，而out不需要。"><a href="#区别2：ref参数在使用前必需初始化，而out不需要。" class="headerlink" title="区别2：ref参数在使用前必需初始化，而out不需要。"></a>区别2：ref参数在使用前必需初始化，而out不需要。</h4><p><img src="https://s1.ax1x.com/2020/10/14/0Ir3oF.png" alt="0Ir3oF.png"><br>如果ref参数初始化时没有赋值，编译器会报错。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;string str &#x3D; &quot;Hello&quot;;</span><br><span class="line">    string str;</span><br><span class="line">    RefTest(ref str);       &#x2F;&#x2F;error</span><br><span class="line">    outTest(out str);</span><br><span class="line"></span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void outTest(out string str)</span><br><span class="line">&#123;</span><br><span class="line">    str &#x3D; &quot;Bye&quot;;</span><br><span class="line">    Console.WriteLine(str);     &#x2F;&#x2F;output: Bye</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void RefTest(ref string str)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(str);     &#x2F;&#x2F;output: Hello</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>MSDN中对ref关键字的定义：<br>ref 关键字使参数按引用传递。其效果是，当控制权传递回调用方法时，在方法中对参数所做的任何更改都将反映在该变量中。若要使用 ref 参数，则方法定义和调用方法都必须显式使用 ref 关键字。</p>
</blockquote>
<p>ref是直接对值的直接引用，即直接指向内存地址，以下面的代码为例，如果在方法中更改了参数的值，那原变量的值也会随之改变。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">    string str &#x3D; &quot;Hello&quot;;</span><br><span class="line">    RefTest(ref str);       </span><br><span class="line">    outTest(out str);</span><br><span class="line"></span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void outTest(out string str)</span><br><span class="line">&#123;</span><br><span class="line">    str &#x3D; &quot;Bye&quot;;</span><br><span class="line">    Console.WriteLine(str);     &#x2F;&#x2F;output: Bye</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void RefTest(ref string str)</span><br><span class="line">&#123;</span><br><span class="line">    str &#x3D; &quot;it is changed&quot;;      &#x2F;&#x2F;所做的任何更改都将反映在该变量中</span><br><span class="line">    Console.WriteLine(str);     &#x2F;&#x2F;output: it is changed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>通俗的从功能上来讲，使用这两个关键字，可以使一个方法返回多个参数。<br>out适合用在需要retrun多个返回值的地方，而ref则用在需要被调用的方法修改调用者的引用的时候。</p>
<p>参考：<a href="https://www.cnblogs.com/windinsky/archive/2009/02/13/1390071.html" target="_blank" rel="noopener">InSky的博文</a></p>
]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>DeadCellEvolve</title>
    <url>/2020/05/29/DeadCellEvolve/</url>
    <content><![CDATA[<h1 id="When-We-Made…-Dead-Cells"><a href="#When-We-Made…-Dead-Cells" class="headerlink" title="When We Made… Dead Cells"></a>When We Made… Dead Cells</h1><blockquote>
<p>本篇为译文，原文地址:<a href="https://www.mcvuk.com/development-news/when-we-made-dead-cells/" target="_blank" rel="noopener">传送门</a>  </p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/05/29/tuoHq1.jpg" alt="tuoHq1.jpg">  </p>
<p>视频游戏的开发都是关于迭代，一个好的想法会有成百上千的原型和失败的项目。《死亡细胞》也不例外，在成为广受好评的“roguelik-meets-metroidvania”头衔之前，它一开始是作为一款多人塔防游戏发家的。  </p>
<a id="more"></a>

<p><img src="https://s1.ax1x.com/2020/05/29/tuXE0H.jpg" alt="tuXE0H.jpg">     </p>
<p>“它开始于三四年前，”首席开发者兼游戏设计师Sébastien Bénard开始解释说。”当时，Motion Twin还在做网页游戏和一些手机游戏，但我们想为我们的老游戏《Hordes》（又名《Die2Nite》）做一些精神上的续集。这款游戏一开始是一款免费游戏，是一款塔防类的游戏，和其他游戏不同。它到了原型阶段，所以我们确实有一个alpha版本，我们向人们展示了它，但并不顺利，因为它真的不好玩，就像真的不好玩一样，”他笑道。  </p>
<p>“在这一点上，我们决定取消它也许是个好主意，但我们做了一个单人原型，在Gamescom这样的活动中展示。我的一个朋友告诉我们：’也许你们应该保留单人游戏的原型，因为它实际上比多人游戏更有趣。起初，这真的只是一个玩笑，但有一次，我们想:”等等，也许他是在开玩笑。等等，也许他是对的，也许删掉一切是个好主意。”所以我们就这么做了！我们从这个老式的横向卷轴塔防游戏中删除了很多元素，包括多人游戏、移动游戏和免费游戏等元素，这就成就了我们制作的这款恶魔城的游戏。”  </p>
<p>Motion Twin拥有17年的浏览器和手机游戏开发经验，但《死亡细胞》是其首款如此规模的游戏，面向PC和主机玩家。  </p>
<p>“这是完全不同的，因为当你做一款免费游戏的时候，你真正考虑的是游戏的生命周期。当你做一个PC游戏的时候，你更多的是考虑的当然是游戏的质量，但只是制作一个出色的游戏玩法，而不是做一个冗长的游戏或者是让人付费的工具。但因为我们也有这样的经验，所以当我们做roguelike部分的时候，事情就简单了一些。因为我们希望有一款能吸引你的游戏，所以我们确实用这种经验做了《死亡细胞》的玩法。这真的是一件很不一样的事情，但它并不难，对我们来说更像是一种解脱，因为我们实际上把所有没有成功的东西都带来了，所以这是一个很好的过程。”  </p>
<p>但尽管团队经验丰富，但将roguelike和metroidvania这样复杂的两个流派嫁接在一起仍然不是一件容易的事，前者需要程序化生成的关卡，而后者是一个已知的环境，你可以在其中一点一点地进化。  </p>
<p>“最大的挑战真的与关卡设计有关，”Bénard说。”你知道当你做一个metroidvania的时候，你必须花相当多的时间来确保关卡设计是建立在你会进步的想法上。你会看到一些你一开始不能用的东西，但你会进步，你会回来的。尤其是这种回溯的想法，回到你已经知道的地方。  </p>
<p>“但因为我们想要一个程序化的世界，所以我们知道如果真的有一个你记得不可能穿越的地方，那就没有意义了。所以这真的是我们最困难的部分：确保你每次探索的时候都能真正拥有一个不一样的世界，但仍然能很好地了解到你能做什么，不能做什么，以及当你得到一个新的能力时，你应该去哪里使用它。”  </p>
<p>Motion Twin 解决这个问题的方法之一是通过添加符文，永久升级，让你访问最初被屏蔽的路径类型。你在之前的运行中看到的那个地洞？你现在可以用它来长出一根藤蔓，进入一个新的位置。当然还有武器和物品，你在每次运行时都会解锁，典型的roguelike风格。其实《死亡细胞》经常被拿来和《以撒的结合》相提并论。埃德蒙-麦克米伦的这一击确实是灵感的来源，但并不是我们所想的那样。  </p>
<p><img src="https://s1.ax1x.com/2020/05/29/tuIfcd.jpg" alt="tuIfcd.jpg">  </p>
<p>“《黑暗之魂》对我们来说是一个很明显的参考，主要是因为它的困难难度、以及相当困难难度。它不仅仅是要做一个有难度的游戏 而是要做一个相当难度的游戏。”  </p>
<p>“《以撒的结合》是一个很好的参考，但也有它的缺点。”Bénard说。”这真的是一款roguelike游戏，在这里你有大量不同的物品。但问题是，正因为如此，当你在《以撒的结合》中开始一个新的游戏时，你有很低的几率能有一个很好的开局，因为你有这么多不同的物品，而且大多数都不是那么强大。这是我们想尽量避免的事情，要确保你玩的时候，大部分的开局应该是可行的。”    </p>
<p><img src="https://s1.ax1x.com/2020/05/29/tuIW1H.jpg" alt="tuIW1H.jpg">  </p>
<p>因此，Motion Twin决定在游戏中加入 “不一定要少一些，但要多一些有影响力的物品”，这样每一次的开局都可以有不同的玩法，但相同的几率可以做到最后。然而，在《死亡细胞》中，要想 “走到最后 “显然不是那么容易的，死亡就在每一个角落。这就引出了游戏的下一个灵感–是的，你可能已经猜到了。  </p>
<p>“作为一个笑话，我们想在会议室里放一个罐子，所以每当有人说’黑暗之魂’的时候，你就应该把2英镑放进去。”贝纳尔笑着说。”《黑暗之魂》对我们来说是一种明显的参考，主要是因为它困难难度–还有它的相当困难难度。这不仅仅是为了制作一款困难的游戏，而是为了制作一款相当难度的游戏，所以《黑暗之魂》就是一个很好的例子。但也有《Risk of Rain》是一个非常好的平台游戏roguelike，因为它是一个非常简单的游戏，但它有很多非常聪明的想法。而《暗黑破坏神III》也是因为他们如何打磨了一切，以及从《暗黑破坏神II》到《暗黑破坏神III》的所有变化，以及他们做得有多好。”  </p>
<h2 id="社区的声音"><a href="#社区的声音" class="headerlink" title="社区的声音"></a>社区的声音</h2><p>Motion Twin早在2017年5月就为《死亡细胞》选择了Steam Early Access，然后在今年8月在PC和游戏机上正式发布。但工作室热衷于避免了Early Access的常见套路：把游戏放在那里多年来一直处于半开发状态。  </p>
<p>“我们向玩家们宣布，我们想进入Early Access的时间只有一年，实际上因为游戏机移植的原因，我们多花了6个月的时间，但我们真的想确保，因为我们宣布了一年，所以就会是一年。”Bénard说。”所以我们不得不在游戏中推掉了一些东西。我们想有一个另类的结局，所以这就是我们决定保留的东西，可能会在明年年初发布的免费DLC。但我们仍然想确保发行版会尽可能地让玩家感觉到完整。”  </p>
<p>死亡细胞》在早期访问期间发展了很多，比如说，武器上的统计值锻造能力已经被放弃了。玩家的反馈在游戏的制作过程中是非常重要的。  </p>
<p>“Early Access刚开始的时候，我们以为只是增加内容和平衡一些东西，但我们并没有打算改变一切。但实际上在Early Access的第一个月之后，我们从社区中得到了很多有趣的反馈。他们实际上真正理解了游戏的意义。所以我们决定改变了很多重要的东西，尤其是你在游戏中如何建立你的角色，如何发展和世界的结构。”  </p>
<p><img src="https://s1.ax1x.com/2020/05/29/tu7W3F.gif" alt="tu7W3F.gif">  </p>
<p>在发展的过程中，在早期访问之前，也有急剧发展的东西，是主角的设计，只知道囚犯和，有大量的细胞的头的设计。  </p>
<p>“有些是一种偶然的过程，因为我们对这个角色没有一个非常明确的规划。所以，这是我们在一个非常反复的过程中决定的。刚开始的时候，这个角色过去是有一个头，但这是我们改变的东西，”Bénard解释说，并补充说团队觉得这个设计不够突出。”这导致了很多有趣的事情。因为这个角色没有头，他不能说话，而且因为他不能说话，他有很多非常有趣的动画和事情要做。即使他不会说话，但还是觉得他有很强的性格，即使他不会说话。所以这是一开始没有明确决定的东西，但在游戏中逐渐出现了。”  </p>
<h2 id="改造"><a href="#改造" class="headerlink" title="改造"></a>改造</h2><p>为了创建《死亡细胞》，Motion Twin使用了Haxe和Heaps语言作为框架。  </p>
<p>“Haxe是我们多年前创建的一种自定义语言，”Bénard解释说，这让团队能够在已知的领域内，在某些方面让每个人的生活变得更加轻松。  </p>
<p>“起初，这个语言是为了创建跨平台的游戏而做的。因为我们还在做网页游戏和移动端，我们希望有一种语言能够为Flash或苹果或安卓或其他任何我们想要的平台做一些东西。而当我们决定将《死亡细胞》制作成metroidvania的单机游戏时，我们决定坚持使用这个引擎，因为我们知道它的核心是为了在任何平台上工作。所以一开始是Steam版，但也是针对游戏机的，所以我们可以很容易地进行移植。比如说Xbox版或Switch，我们大概花了一两个月的时间来做基本的移植，所以速度相当快。”  </p>
<p>他还解释说，仍然存在一些挑战，Switch的混合特性带来了主要挑战。  </p>
<p>“从技术方面来说，这并不复杂，因为现在的每个控制台都有相当经典的架构。最重要的挑战，尤其是对Switch来说，是屏幕尺寸太小，或者说屏幕离你3米远。所以对于UI来说，我们确实有很多东西需要调整，以确保它总是清晰可辨，而且你可以在任何距离上看到所有的细节和一切。这对我们来说是最复杂的部分。”  </p>
<p>在发售后不久，Motion Twin就透露《死亡细胞》在Switch上的销售速度是PS4上的四倍。所以听起来，团队似乎钉住了他们为数不多的移植挑战。随着DLC和更新的公布，包括更多关注速跑社区的DLC，《死亡细胞》将迎来黄金时代。但Motion Twin并不想太过依赖这种成功。  </p>
<p>“我们想在《死亡细胞》上多做一些工作，因为我们还有一些想法没有时间投入，但是可能在明年年初，我们会开始着手做下一个项目。但我们有额外内容的计划，所以我们可能会不时推送额外的免费DLC、平衡补丁或类似的东西。所以我不能确定会持续多久，但我们想确保………..，”他停顿了一下，然后补充道，”直到游戏完成为止。”  </p>
<p>“因为我们是一家老公司，我们之前确实有很多不同的头衔，我们很确定地知道，坚持一款游戏、一次成功，并不是一个好主意。所以当你做出一款好的游戏时，最好的办法就是再做一款。”Bénard笑着说。  </p>
<br>  
<br>  
]]></content>
      <categories>
        <category>译文</category>
      </categories>
      <tags>
        <tag>单机</tag>
        <tag>搬运</tag>
        <tag>译文</tag>
      </tags>
  </entry>
  <entry>
    <title>Gneric Note</title>
    <url>/2020/06/09/Gneric-Note/</url>
    <content><![CDATA[<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型（Generic） 允许您延迟编写类或方法中的编程元素的数据类型的规范，直到实际在程序中使用它的时候。换句话说，泛型允许您编写一个可以与任何数据类型一起工作的类或方法。  </p>
<a id="more"></a>

<h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><blockquote>
<p>泛型允许编写一个可以与任何数据类型一起工作的的类或方法。<br>泛型类允许延迟编写类中编程元素的数据类型，即类中某些字段的类型是不确定的，这些数据类型可以在类构造的时候确定下来。  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ClassA&lt;T&gt;     &#x2F;&#x2F;当使用ClassA构造时需要指定T的数据类型</span><br><span class="line">&#123;</span><br><span class="line">    private T a;</span><br><span class="line">    private T b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>泛型方法就是定义一个方法，这个方法的参数类型是不确定的，在调用该方法的时候再确定方法的参数类型。  </p>
<h2 id="集合类-列表List"><a href="#集合类-列表List" class="headerlink" title="集合类 列表List"></a>集合类 列表List</h2><p>当我们有很多类型一样的数据时，一般用数组来管理，但是数组的大小是固定的。而集合类中的列表(List)可以让我们方便对数据进行添加、删除等操作。  </p>
<h3 id="列表List的创建和使用"><a href="#列表List的创建和使用" class="headerlink" title="列表List的创建和使用"></a>列表List的创建和使用</h3><p>1.创建列表：</p>
<blockquote>
<p>列表可以存储任何类型的数据，在创建列表对象的时候首先要在&lt;&gt;中指定该列表的存储类型。 </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;int&gt; scoreList &#x3D; new List&lt;int&gt;();</span><br><span class="line">List&lt;int&gt; scoreList2 &#x3D; new List&lt;int&gt;()&#123;1,2,3&#125;;</span><br><span class="line">List&lt;int&gt; scoreList3 &#x3D; new List&lt;int&gt;()&#123;&quot;one&quot;,&quot;two&quot;,&quot;three&quot;&#125;;</span><br><span class="line"></span><br><span class="line">var scoreList &#x3D; new List&lt;int&gt;();</span><br></pre></td></tr></table></figure>

<p>2.往列表里插入数据：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scoreList.Add(12);</span><br><span class="line">scoreList.Add(45);</span><br></pre></td></tr></table></figure>

<p>3.获取列表中的数据：</p>
<blockquote>
<p>列表中的数据和数组的类似，索引从0开始，可以通过索引来访问。  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scoreList[0]        &#x2F;&#x2F;访问添加到列表中的第一个数据</span><br></pre></td></tr></table></figure>

<h3 id="列表的容量"><a href="#列表的容量" class="headerlink" title="列表的容量"></a>列表的容量</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;int&gt; intList &#x3D; new List&lt;int&gt;(10);      &#x2F;&#x2F;创建了一个初始容量为10的列表</span><br></pre></td></tr></table></figure>

<p>当容量不够用的时候，列表每次都会按照原来容量的2倍进行扩容。  </p>
<p>我们可以使用Capacity属性获取和设置容量：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">intList.Capacity &#x3D; 100;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意列表容量和列表元素个数的区别，容量可通过Capacity获取，元素个数通过Count获取。</p>
</blockquote>
<h3 id="列表的遍历"><a href="#列表的遍历" class="headerlink" title="列表的遍历"></a>列表的遍历</h3><ul>
<li>通过for循环，遍历所有的索引，通过索引访问列表中的元素  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(int i &#x3D; 0; i &lt; List.Count; i++)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(List[i]);     &#x2F;&#x2F;etc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>foreach遍历输出  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foreach(&lt;data type&gt; temp in List)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(temp);        &#x2F;&#x2F;etc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="操作列表常用的属性和方法"><a href="#操作列表常用的属性和方法" class="headerlink" title="操作列表常用的属性和方法"></a>操作列表常用的属性和方法</h3><ul>
<li>1.Capacity 获取容量大小；</li>
<li>2.Add() 方法添加元素；</li>
<li>3.Insert() 方法插入元素；</li>
<li>4.[index] 访问元素；</li>
<li>5.Count 属性访问元素个数；</li>
<li>6.RemoveAt() 方法移除指定位置的元素；</li>
<li>7.IndexOf()/LastIndexOf() 方法获取一个元素在列表中的索引位置；（前者从前往后搜索，后者从后往前搜索）</li>
<li>8.Sort() 对列表中的元素进行从小到大排序。  </li>
</ul>
<h4 id="Object-Euqals"><a href="#Object-Euqals" class="headerlink" title="Object.Euqals"></a>Object.Euqals</h4><p>在获取元素在列表/数组中的索引位置时，当调用了一个泛型类的方法来获取目标索引位置时，需要把未知类型的数组元素和目标元素进行比较的时候，是不能通过关系运算符（array[i] == item）来进行比较的，这时候我们可以通过<code>Object.Equals</code>方法可以确定两个示例对象是否相等（或者说内容是否一致）。<br>例如：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MyList&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    private T[] array;</span><br><span class="line">    private int count &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    public int IndexOf(T item)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (array[i].Equals(item))</span><br><span class="line">            &#123;</span><br><span class="line">                return i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>CSharp中的调试与错误处理</title>
    <url>/2020/05/18/CSharpDebug/</url>
    <content><![CDATA[<h2 id="正常模式下的调试"><a href="#正常模式下的调试" class="headerlink" title="正常模式下的调试"></a>正常模式下的调试</h2><ul>
<li>1.在VS中 我们使用<code>Console.Write(或者WriteLine)</code>方法向控制台输出变量的值，通过查看变量值是否符合预期来调试错误。</li>
<li>2.在Unity中我们使用<code>Debug.Log(&quot;&quot;) Debug.LogError(&quot;&quot;) Debug.LogWarn9(&quot;&quot;)</code>，向unity的Console窗口输出信息，帮助我们调试错误。<a id="more"></a>

</li>
</ul>
<h2 id="中断模式下的调试"><a href="#中断模式下的调试" class="headerlink" title="中断模式下的调试"></a>中断模式下的调试</h2><p>断点是源代码中自动进入中断模式的一个标记，当遇到断点的时候，程序会进入中断模式。</p>
<h3 id="如何插入断点"><a href="#如何插入断点" class="headerlink" title="如何插入断点?"></a>如何插入断点?</h3><ul>
<li>1.右击代码行，选择breakpoint，insert breakpoint。</li>
<li>2.光标定位到代码行，菜单-debug-Toggle breakpoint。</li>
<li>3.光标定位到代码行，按F9插入brakpoint，再次按下删除。</li>
<li>4.在行首位置直接单击添加，再次单击删除。</li>
</ul>
<h3 id="中断模式下监视、修改变量"><a href="#中断模式下监视、修改变量" class="headerlink" title="中断模式下监视、修改变量"></a>中断模式下监视、修改变量</h3><p>中断模式下查看变量值最简单的方法即把鼠标指向源代码中的变量名，会出现提示显示该变量信息。<br>中断模下界面的左下角会有三个选项卡，其中两个是：</p>
<blockquote>
<p>局部变量 -当前运行环境中所有局部变量的类型和值<br>监视 -监视变量值的变化  </p>
</blockquote>
<p><code>局部变量</code>选项卡内可以直接查看或修改变量信息：  </p>
<p><img src="https://s1.ax1x.com/2020/05/18/YhgF4f.png" alt="YhgF4f.png"> </p>
<p><code>监视</code>前需要添加变量对象：  </p>
<p><img src="https://s1.ax1x.com/2020/05/18/YhgE8S.png" alt="YhgE8S.png"> </p>
<h3 id="调用堆栈和即时窗口"><a href="#调用堆栈和即时窗口" class="headerlink" title="调用堆栈和即时窗口"></a>调用堆栈和即时窗口</h3><p>中断模式下界面右下角可以选择<code>调用堆栈</code>和<code>即时窗口</code>  </p>
<blockquote>
<p><code>调用堆栈</code>可以查看运行进度和代码的被调用情况  </p>
</blockquote>
<p><a href="https://imgchr.com/i/YhgAC8" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/05/18/YhgAC8.png" alt="YhgAC8.png"></a></p>
<blockquote>
<p>我们可以在<code>即时窗口</code>输入命令，查看、修改变量值，或输入表达式查看结果。  </p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/05/18/YhgiUP.png" alt="YhgiUP.png"></p>
<h3 id="单步执行代码"><a href="#单步执行代码" class="headerlink" title="单步执行代码"></a>单步执行代码</h3><p>中断模式下可以单步执行代码，分<code>逐过程</code>和<code>逐语句</code>，同样是逐条语句运行，但是逐语句执行遇到函数时不会进入函数。  </p>
<h2 id="错误处理-异常处理"><a href="#错误处理-异常处理" class="headerlink" title="错误处理(异常处理)"></a>错误处理(异常处理)</h2><p>处理异常的语法结构：  </p>
<pre><code class="c#"><span class="keyword">try</span>{ 
    ···     <span class="comment">//包含可能出现异常的代码</span>
}
<span class="keyword">catch</span>(&lt;exceptionType&gt;e){    <span class="comment">//当catch参数不写时，会捕捉任何出现的异常</span>
    ···     <span class="comment">//当出现的异常类型和cath块中的异常类型一样时，捕捉异常。</span>
<span class="keyword">finally</span>{  
    ···     <span class="comment">//包含始终会执行的代码</span>
}</code></pre>
]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象：类定义/构造/属性</title>
    <url>/2020/05/27/Object-oriented/</url>
    <content><![CDATA[<h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h2><p>对象是类的实例，构成类的方法和变量是类的成员。<br>定义类的一般形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;access specifier&gt; class  class_name</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; member variables</span><br><span class="line">    &lt;access specifier&gt; &lt;data type&gt; variable1;</span><br><span class="line">    &lt;access specifier&gt; &lt;data type&gt; variable2;</span><br><span class="line">    ...</span><br><span class="line">    &lt;access specifier&gt; &lt;data type&gt; variableN;</span><br><span class="line">    &#x2F;&#x2F; member methods</span><br><span class="line">    &lt;access specifier&gt; &lt;return type&gt; method1(parameter_list)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; method body</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;access specifier&gt; &lt;return type&gt; method2(parameter_list)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; method body</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    &lt;access specifier&gt; &lt;return type&gt; methodN(parameter_list)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; method body</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>



<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>每当创建类或结构时，将会调用其构造函数。 类或结构可能具有采用不同参数的多个构造函数。 使用构造函数能够设置默认值、限制实例化。  </p>
<p>构造函数是一种方法，其名称与其类型的名称相同。 其方法签名仅包含方法名称和其参数列表；它不包含返回类型。 以下示例演示一个名为 <code>Person</code> 的类的构造函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Person</span><br><span class="line">&#123;</span><br><span class="line">   private string last;</span><br><span class="line">   private string first;</span><br><span class="line"></span><br><span class="line">   public Person(string lastName, string firstName)</span><br><span class="line">   &#123;</span><br><span class="line">      last &#x3D; lastName;</span><br><span class="line">      first &#x3D; firstName;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; Remaining implementation of Person class.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>属性可以使用<code>访问器(accessors)</code>使得私有域的值可以被读写或操作。<br>例如，有一个名为 Student 的类，带有 age、name 和 code 的私有域。我们不能在类的范围以外直接访问这些域，但是我们可以拥有访问这些私有域的属性。<br>定义结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 声明类型为 string 的 Code 属性</span><br><span class="line">public string Code      &#x2F;&#x2F;定义属性需要名字和类型</span><br><span class="line">&#123;</span><br><span class="line">   get</span><br><span class="line">   &#123;</span><br><span class="line">      return code;      </span><br><span class="line">   &#125;</span><br><span class="line">   set</span><br><span class="line">   &#123;</span><br><span class="line">      code &#x3D; value;     &#x2F;&#x2F;通过value关键字访问code值         </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自动实现的属性：<br>当get、set块中没有字段时，编译器会自动给我们生成一个字段用以存储值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public string Code &#123;get;set;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="如何声明和使用读-写属性"><a href="#如何声明和使用读-写属性" class="headerlink" title="如何声明和使用读/写属性"></a>如何声明和使用读/写属性</h3><p>属性提供了公共数据成员的便利性，且不会产生未受保护、不可控制和未经验证地访问对象的数据的风险。 可以通过访问器实现从基础数据成员中检索值或赋值。<br><code>get</code>访问器可检索数据成员值（读），<code>set</code>访问器可以分配数据成员（写）。<br>示例： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">    private string _name &#x3D; &quot;N&#x2F;A&quot;;</span><br><span class="line">    private int _age &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Declare a Name property of type string:</span><br><span class="line">    public string Name</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            return _name;</span><br><span class="line">        &#125;</span><br><span class="line">        set</span><br><span class="line">        &#123;</span><br><span class="line">            _name &#x3D; value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Declare an Age property of type int:</span><br><span class="line">    public int Age</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            return _age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        set</span><br><span class="line">        &#123;</span><br><span class="line">            _age &#x3D; value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public override string ToString()</span><br><span class="line">    &#123;</span><br><span class="line">        return &quot;Name &#x3D; &quot; + Name + &quot;, Age &#x3D; &quot; + Age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TestPerson</span><br><span class="line">&#123;</span><br><span class="line">    static void Main()</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; Create a new Person object:</span><br><span class="line">        Person person &#x3D; new Person();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Print out the name and the age associated with the person:</span><br><span class="line">        Console.WriteLine(&quot;Person details - &#123;0&#125;&quot;, person);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Set some values on the person object:</span><br><span class="line">        person.Name &#x3D; &quot;Joe&quot;;</span><br><span class="line">        person.Age &#x3D; 99;</span><br><span class="line">        Console.WriteLine(&quot;Person details - &#123;0&#125;&quot;, person);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Increment the Age property:</span><br><span class="line">        person.Age +&#x3D; 1;</span><br><span class="line">        Console.WriteLine(&quot;Person details - &#123;0&#125;&quot;, person);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Keep the console window open in debug mode.</span><br><span class="line">        Console.WriteLine(&quot;Press any key to exit.&quot;);</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* Output:</span><br><span class="line">    Person details - Name &#x3D; N&#x2F;A, Age &#x3D; 0</span><br><span class="line">    Person details - Name &#x3D; Joe, Age &#x3D; 99</span><br><span class="line">    Person details - Name &#x3D; Joe, Age &#x3D; 100</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>
<h3 id="可靠编程：限制访问器的可访问性"><a href="#可靠编程：限制访问器的可访问性" class="headerlink" title="可靠编程：限制访问器的可访问性"></a>可靠编程：限制访问器的可访问性</h3><p>属性中可以同时包含<code>get</code>和<code>set</code>访问器，默认情况下，它们具有与所属属性或索引器相同的可见性或访问级别。但是有时限制对其中某个访问器的访问是有益的，一般是可读不可写，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private string _name &#x3D; &quot;Hello&quot;;</span><br><span class="line"></span><br><span class="line">public string Name</span><br><span class="line">&#123;</span><br><span class="line">    get</span><br><span class="line">    &#123;</span><br><span class="line">        return _name;</span><br><span class="line">    &#125;</span><br><span class="line">    protected set</span><br><span class="line">    &#123;</span><br><span class="line">        _name &#x3D; value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当属性带有<code>override</code>修饰符时，访问器修饰符必须与重写的访问器的修饰符匹配。</p>
</blockquote>
<h3 id="重写访问器的访问修饰符"><a href="#重写访问器的访问修饰符" class="headerlink" title="重写访问器的访问修饰符"></a>重写访问器的访问修饰符</h3><p>重写属性或索引器时，被重写的访问器对重写代码而言必须是可访问的。 此外，属性/索引器及其访问器的可访问性都必须与相应的被重写属性/索引器及其访问器匹配。 例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Parent</span><br><span class="line">&#123;</span><br><span class="line">    public virtual int TestProperty</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; Notice the accessor accessibility level.</span><br><span class="line">        protected set &#123; &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; No access modifier is used here.</span><br><span class="line">        get &#123; return 0; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Kid : Parent</span><br><span class="line">&#123;</span><br><span class="line">    public override int TestProperty</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; Use the same accessibility level as in the overridden accessor.</span><br><span class="line">        protected set &#123; &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Cannot use access modifier here.</span><br><span class="line">        get &#123; return 0; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>HelloWorld</title>
    <url>/2020/05/15/HelloWorld/</url>
    <content><![CDATA[<h1 id="起初"><a href="#起初" class="headerlink" title="起初"></a>起初</h1><p>第一次接触到博客的时候是在博客园无意间进入了一位大佬的个人博客，乍一看觉得还挺好看，想着“这是一个人能做出来的东西吗？有点酷欸…”，但后来略微浏览了之后，发现这博主一直在持续输出高质量的技术博客，其中不乏各种学习历程和项目经验。想来自己如若能简要搭建一个博客，对个人生活而言、对编程等学习的记录也是挺有意义的，由此我便萌生了自己搭建博客的想法。</p>
<a id="more"></a>
<h1 id="现在"><a href="#现在" class="headerlink" title="现在"></a>现在</h1><p>刚开始个人对搭建博客的认识是：通过花钱买域名、主机、服务器，然后自己编写前端代码，然后搭建好后要各种测试，并时而进行维护，搭建好并长期使博客正常运行就要花费不菲的金钱和时间，且需要一定的相关技术水平。考虑到自己作为学生，经济水平有限，而且前端的知识也忘得七七八八了，自己从零开始搭建博客难免会有点困难。后来通过<a href="http://www.ityouknow.com/" target="_blank" rel="noopener">纯洁的微笑</a>博客中一篇关于通过GithubPages来搭建自己博客的方法，就开始着手在网上搜索相关的教程。网络上的教程大多比较零散，要不就是不够详细，作为新人刚开始也是看得云里雾里的。在看完东家一边看西家的过程中，发现了一位师兄<a href="https://sunhwee.com/" target="_blank" rel="noopener">洪卫</a>的教程，他的教程十分详尽，对我帮助很大。在第1天的时候主要在配置相关环境(git,nodejs),安装Hexo然后创建项目并将Github和本地同步，有了一个初步的雏形。第2天大部分时间都在定制、修改主题模板，在这里要感谢<a href="https://github.com/Shen-Yu" target="_blank" rel="noopener">沈宇</a>提供的Ayer。最后在git中添加插件，熟悉在博客中添加文章、编辑文章、上传文章的操作，基本完成了这个真`简洁的博客搭建。</p>
<h1 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h1><p>曾经在一段时间内喜欢四处去浏览别人的博客，不记得在哪看到过一篇文章，讲的是一个博客不管它看起来有多好看，不管它搭建的时候用了多高级的技术，这只是一个博客的起点，作为一个博客，它最重要的是在剩下的时间里保持输出优质、有意义的内容。这个博客个人希望在未来能用于自己的学习记录和生活记录, 以此督促自己, 以期成为更好的自己, Hello World!</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>无“声”胜有“声”——《Inside》中异于传统的叙事手段</title>
    <url>/2020/05/27/InsideNarrative/</url>
    <content><![CDATA[<p><img src="https://s1.ax1x.com/2020/05/29/tKnxf0.jpg" alt="tKnxf0.jpg"></p>
<blockquote>
<p>“如果说《火情观察员》是2016年独立游戏界燃起的第一把火，那么来自曾经以《Limbo》蜚声业界的独立游戏工作室Playdead的新作《Inside》，毫无疑问就是第二把，只是这把火要烧的更高，影响也显然更为深远。” ——RED  </p>
</blockquote>
<a id="more"></a>  

<h2 id="青出于蓝胜于蓝"><a href="#青出于蓝胜于蓝" class="headerlink" title="青出于蓝胜于蓝"></a>青出于蓝胜于蓝</h2><p>《Inside》是一款由独立游戏工作室Playdead所开发及发行的平台解谜及冒险游戏。该主题和视觉效果类似Playdead的上一款作品：《Limbo》（地狱边境），游戏中玩家需要扮演一个小男孩探索一个超现实的环境，在黑白色的游戏环境中避开危险并解决不同的难题。  </p>
<p>《Inside》和《Limbo》有许多相似之处：叙事层面上两作中都出现了相同的元素，像《Limbo》中会控制主角行为的虫子也出现在了《Inside》中的猪身上；     </p>
<p><img src="https://s1.ax1x.com/2020/05/25/tCweot.png" alt="tCweot.png">  </p>
<p>游戏模式上，两者都是简洁而精巧的<code>平台动作解谜游戏</code>，谜题设计思路相对一致；画面风格上同样是以黑白为主色调，利用一些溅出的色块或光影效获来突出部分环境。  </p>
<p>和《Limbo》相似，《Inside》整个游戏过程都没有一句对白或旁白，连教程都没有，玩家刚进入游戏就能通过简单的四个方向、推拉动作来操控小男孩。没有传统解密游戏那般絮絮叨叨的游戏对白、四处分散的纸张或书籍来充当一个叙事手段，《Inside》需要通过在场景设计和谜题设计上下更多的功夫，让玩家在没有旁白的情况下也能通过游戏场景和谜题的元素自己揣测出游戏所想要表述的内容。  </p>
<h2 id="简明但不简单的场景布置"><a href="#简明但不简单的场景布置" class="headerlink" title="简明但不简单的场景布置"></a>简明但不简单的场景布置</h2><p>这一个个游戏场景、或明或暗的各种游戏细节、谜题元素贯穿着整个游戏流程，在不着一字的《Inside》中，它们成了表叙游戏内容、体现游戏主题最为关键的部分。同它的前作一样，即使《Inside》在色彩上丰富些，但是整体给人感觉还是挺压抑的。灰暗的基调、陈旧的环境、奇怪甚至可以说是惊悚的“人”，无一不是在给玩家铺垫一种反乌托邦的气氛，一种绝望压抑、令人恐惧的假想社群或社会。  </p>
<p><img src="https://s1.ax1x.com/2020/05/26/tFhMH1.png" alt="tFhMH1.png">  </p>
<p><strong><em>小男孩歪打正着掉进了这条木讷的队伍中，这些人仿佛是没有灵魂的躯壳，队伍旁边是一台监督队伍前进的机器，主角为了生存只能混入其中，模仿这些躯壳机械地向前走。像是在社会中有的人为了生存，会接受摆布、违背意愿地去加入原本自己不认同的生活，丧失了自己辨别是非的能力，逐渐麻木。</em></strong>   </p>
<p><img src="https://s1.ax1x.com/2020/05/26/tFhuu9.png" alt="tFhuu9.png">  </p>
<p><strong><em>在冲击波肆虐的场景中，人是显得多么脆弱和渺小，在坚固的掩体之外，稍有不慎小男孩就会给带走。这种强烈鲜明的对比，我们在某东战场是不是也见过类似的场景？两军交战炮火肆虐，无辜的平民搂着怀里的孩童躲在掩体后瑟瑟发抖，普通人在战争面前是多么的脆弱与无助。</em></strong>  </p>
<p><img src="https://s1.ax1x.com/2020/05/26/tFhKBR.png" alt="tFhKBR.png">  </p>
<p><strong><em>残破的建筑内，一排排的假人被固定在座椅上，头颅低垂，被外面震荡波一遍又一遍地冲击着···</em></strong>   </p>
<p><img src="https://s1.ax1x.com/2020/05/26/tFhec4.png" alt="tFhec4.png">  </p>
<p><strong><em>在小男孩解救肉团的地方，能看到在这个大型“容器”外，有一群人似乎在观察什么。</em></strong>  </p>
<h2 id="政治隐喻角度的解读"><a href="#政治隐喻角度的解读" class="headerlink" title="政治隐喻角度的解读"></a>政治隐喻角度的解读</h2><p>对于《Inside》想要表达的主题思想，有相当一部分媒体认为<code>乔治·奥威尔</code>的政治隐喻小说《一九八四》对这部游戏的思想有着深刻的影响。小说的中的重点是探讨政府权力过分伸张、极权主义、对社会所有人和行为实施压抑性统治的风险。作为反乌托邦小说三部代表作之一，在小说的构想中，世界大部分地区都陷入了战争中，政府监控无处不在，国家由政党支配，它雇用思想警察去迫害个人主义者以及独立思考者。在大概了解之后，不难发现《Inside》中许多场景或细节在对照小说内容后，其隐喻的对象也就逐渐清晰了起来。  </p>
<h2 id="结局"><a href="#结局" class="headerlink" title="结局"></a>结局</h2><p>《Inside》除了标准结局，还有一个隐藏结局(这篇不作赘述)，人们对于结局的解读也没有一个固定的说法，官方也没有给出唯一的解释或解读。正如一千个人心目中有一千个哈姆雷特，也恰巧是这没有标准答案的试卷，让玩家们乐此不疲地去探讨这部作品背后的含义，让我写下了这篇文章。一本好书，经得起读者的往复阅读，每个人、每一次的阅读都可能会有新的体验，这也是为什么《Inside》会引领大量玩家展开对游戏内核的讨论，以至于出现了对“反乌托邦”、“自由意志”、“社会问题”等话题的思考，我想这也是《Inside》的魅力所在。</p>
<p>标准结局下，小男孩最后卯足了劲向那面所谓的墙撞了上去，穿过这层东西后滚到了海岸边，一个和实验室沙盘里的模型一模一样的海岸，最后逐渐没了动静。个人的解读是像小男孩这样有自由意识、独立个性的人在经过一番努力后，冲出“墙”外后，发现自己根本摆脱不了原来世界那种混沌的怪异循环，只不过是又重新成为了一个更大的沙盘中的棋子。(发现结局场景和沙盘一样后，说震惊可能不太准确，是那种后知后觉的惊讶，就和当初看完《紧闭岛》的感觉是一样的。)</p>
<p><img src="https://s1.ax1x.com/2020/05/26/tFh34K.png" alt="tFh34K.png">  </p>
<p><strong><em>小男孩暴走到最后，冲出墙外后，沿着山坡滚到了海岸边，渐渐瘫软下来，游戏也结束了。</em></strong>  </p>
<p><img src="https://s1.ax1x.com/2020/05/26/tFhlAx.png" alt="tFhlAx.png">  </p>
<p><strong><em>其实细心的玩家可能会发现游戏结束时的场景，在之前某个场景里也出现过，如同微缩景观一般，甚至还有一盏灯从高处往下打光来模拟日照······</em></strong>  </p>
<blockquote>
<p>“隐藏结局却走向了另一个极端，以打破第四面墙的方式提出另一层隐喻，告诉玩家我们在生活中也像小男孩一样被他人控制而不自知，应该早点拔下插在自己身上的那根线，以自己的意志活下去，即使这个结局是更加黑暗而绝望的。”   </p>
</blockquote>
<p>游戏需要故事，就正如电影需要故事一般。无论是以何种艺术形式来表达，人至始至终追求的其实是聆听的愉悦，是思维在跟随讲述过程中构筑另类人生的奇妙体验。《Inside》中并没有传统的叙事手段，但它做到了无“声”胜有“声”。我们要理解它想要讲述的故事就需要摒弃一些传统动作解密游戏的游玩思路，从游戏的场景中、谜题中寻找细节，将自己代入到小男孩的位置中，或许才能真正理解这部作品想要传递的内容。  </p>
]]></content>
      <categories>
        <category>游戏测评</category>
      </categories>
      <tags>
        <tag>单机</tag>
        <tag>测评</tag>
      </tags>
  </entry>
  <entry>
    <title>Reverse-integer</title>
    <url>/2020/06/12/Reverse-integer/</url>
    <content><![CDATA[<p>昨天在LeetCode上刷到了一个算法题，在看官方的参考思路时有个点给我卡了一下，在这之前对<code>整数溢出</code>的判断完全没有概念，在这做一下记录。  </p>
<a id="more"></a>

<h2 id="整数反转"><a href="#整数反转" class="headerlink" title="整数反转"></a>整数反转</h2><p><a href="https://leetcode-cn.com/problems/reverse-integer/" target="_blank" rel="noopener">LeetCode URL</a> </p>
<p>题目：给出一个32位的有符号整数，你需要将这个整数中每一位上的数字进行反转。<br><em>示例1：</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：123</span><br><span class="line">输出：321</span><br></pre></td></tr></table></figure>

<p><em>示例2：</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：-123</span><br><span class="line">输出：-321</span><br></pre></td></tr></table></figure>

<p><em>示例3：</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：120</span><br><span class="line">输出：21</span><br></pre></td></tr></table></figure>

<p>注意：假设我们的环境只能存储下32位的有符号整数，则起数值范围为<code>[-2147483648, 2147483647]</code>,请根据这个假设，如果反转后整数溢出那么就返回0。  </p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>思路：<br>我们可以一次构建反转整数中的一位数整数附加另字，反复构建多次得到反转后的整数，同时通过一次构建一位数字的方式，我们就可以预先检查向反转一位数字是否会导致整数溢出。  </p>
<p>算法：  </p>
<blockquote>
<p>反转整数的方法可以与反转字符串的方法进行类比</p>
</blockquote>
<p>通过重复“弹出”原整数中最后一位数字即个位数，然后把该数字“推入”到反转整数的个位上（想象一下，把一个满弹弹夹上的子弹依次填入另一个空弹夹），然后在没有堆栈、数组辅助的情况下用数学方法实现“弹出、推入”，最后得到反转后的整数。  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//pop operation:</span></span><br><span class="line">pop = x % <span class="number">10</span>;</span><br><span class="line">x /= <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//push operation:</span></span><br><span class="line">temp = rev * <span class="number">10</span> + pop;</span><br><span class="line">rev = temp;</span><br></pre></td></tr></table></figure>

<p>当 <code>temp = rev * 10 + pop</code> 时会导致溢出，需要事先检查语句是否会导致整数溢出  </p>
<p><img src="https://s1.ax1x.com/2020/06/12/tqqysH.png" alt="tqqysH.png"></p>
<p>就这个地方，这个7和8那会琢磨了好久愣是一时间没想明白，后来google查了下才知道是指Int最大值和最小值的个位······</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rev = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> pop = x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (rev &gt; INT_MAX/<span class="number">10</span> || (rev == INT_MAX / <span class="number">10</span> &amp;&amp; pop &gt; <span class="number">7</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (rev &lt; INT_MIN/<span class="number">10</span> || (rev == INT_MIN / <span class="number">10</span> &amp;&amp; pop &lt; <span class="number">-8</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            rev = rev * <span class="number">10</span> + pop;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>该<code>reverse(int x)</code>函数反转的十进制数字x。例如，if x = 102，它返回201，如果x = -102返回-201。</p>
<p>x计算反向时，将其存储在<code>rev</code>。例如，对于x = 102，<code>rev</code>取连续值2，20，201。</p>
<p>在每次迭代时，<code>rev</code>乘以10，并向其添加一位数。当然，<code>rev</code>不能大于<code>Integer.MAX_VALUE</code>（2147483647）。因此，乘前<code>rev</code>通过10，我们检查是否乘以它10并加入<code>pop</code>将使其大于<code>Integer.MAX_VALUE</code>。</p>
<p>我们首先检查是否<code>rev</code>大于<code>Integer.MAX_VALUE / 10</code>（214748364）。如果它更大，则不存在反向整数。如果不是，那么<code>rev</code>小于或等于<code>Integer.MAX_VALUE / 10</code>。如果它小于<code>Integer.MAX_VALUE / 10</code>，那么即使我们乘以它10，我们也可以添加任何数字（pop），我们不会超过<code>Integer.MAX_VALUE</code>。但是，如果它等于<code>Integer.MAX_VALUE / 10</code>，那么我们必须确保<code>pop不是&gt; 7</code>（2147483647 - 214748364 * 10）否则我们会超过<code>Integer.MAX_VALUE</code>。</p>
<p>同样的推理适用于Integer.MIN_VALUE（-2147483648）。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Screen的Bounds和WorkingArea的区别</title>
    <url>/2020/11/30/Screen%E7%9A%84Bounds%E5%92%8CWorkingArea%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="Screen中Bounds和WorkingArea的区别"><a href="#Screen中Bounds和WorkingArea的区别" class="headerlink" title="Screen中Bounds和WorkingArea的区别"></a>Screen中Bounds和WorkingArea的区别</h2><h3 id="1-Screen-PrimaryScreen-Bounds"><a href="#1-Screen-PrimaryScreen-Bounds" class="headerlink" title="1.Screen.PrimaryScreen.Bounds"></a>1.Screen.PrimaryScreen.Bounds</h3><p>获取显示的边界。</p>
<p><a href="https://imgchr.com/i/D2Mt6x" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/30/D2Mt6x.png" alt="D2Mt6x.png"></a></p>
<h3 id="1-Screen-PrimaryScreen-WorkingArea"><a href="#1-Screen-PrimaryScreen-WorkingArea" class="headerlink" title="1.Screen.PrimaryScreen.WorkingArea"></a>1.Screen.PrimaryScreen.WorkingArea</h3><p>获取显示器的工作区。工作区是指显示器的桌面区域，不包括任务栏、停靠窗口等。</p>
<p><a href="https://imgchr.com/i/D2MY11" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/11/30/D2MY11.png" alt="D2MY11.png"></a></p>
<h3 id="3-区别"><a href="#3-区别" class="headerlink" title="3.区别"></a>3.区别</h3><p>Bounds 获取的是屏幕的宽和高，而WorkingArea 取得的不是屏幕的宽和高，而是程序运行可以使用的屏幕上的某个范围。<br>这个范围，会因为桌面的任务栏、工具栏之类的存在，而有所改变，所以并不等同于屏幕的宽和高，通常是小一些。</p>
]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>Socket/TcpListener/UdpClient</title>
    <url>/2020/06/26/Socket-TcpListener-UdpClient/</url>
    <content><![CDATA[<p>Socket/TcpListener/UdpClient同属于命名空间<code>System.Net.Sockets</code>，<code>System.Net.Sockets</code>命名空间为需要严密控制网络访问的开发人员提供了 Windows Sockets (Winsock) 接口的托管实现。</p>
<a id="more"></a>

<h2 id="Socket-套接字-编程"><a href="#Socket-套接字-编程" class="headerlink" title="Socket(套接字)编程"></a>Socket(套接字)编程</h2><h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><p>基于<code>TCP协议</code>的Socket通讯类似于B/S架构，面向连接，但不同的是服务器端可以向客户端主动推送消息。  </p>
<p>使用TCP协议通讯需要具备以下几个条件：</p>
<ol>
<li>建立一个<code>套接字</code>(Socket)</li>
<li>绑定服务器端<code>IP地址</code>(IPAddress)和端口号(Port)</li>
<li>利用<code>Listen()</code>方法开启监听</li>
<li>利用<code>Accept()</code>方法尝试与客户端建立一个连接</li>
<li>利用<code>Connect()</code>方法与服务器建立连接</li>
<li>利用<code>Send()</code>方法向建立连接的主机发送消息</li>
<li>利用<code>Recive()</code>方法接收来自建立连接的主机的消息</li>
</ol>
<p><img src="https://s1.ax1x.com/2020/06/26/Nsba26.png" alt="Nsba26.png"></p>
<h3 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h3><p>基于<code>UDP协议</code>是无连接模式通讯，占用资源少，响应速度快，延时低。至于可靠性，可通过应用层的控制来满足。  </p>
<p>使用TCP协议通讯需要具备以下几个条件：</p>
<ol>
<li>建立一个<code>套接字Socket</code></li>
<li>绑定服务器端I<code>P地址及端口号</code></li>
<li>通过<code>SendTo()</code>方法向指定主机发送消息(需提供主机IP和端口号)</li>
<li>通过<code>ReciveFrom()</code>方法接收指定主机发送的消息(需提供主机IP和端口号)</li>
</ol>
<p><img src="https://s1.ax1x.com/2020/06/26/NsbU8x.png" alt="NsbU8x.png"></p>
<h3 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h3><p>TCP协议和UDP协议连接过程的区别：</p>
<ol>
<li>基于连接和无连接；</li>
<li>对系统资源的要求不同，TCP较多，UDP较少；</li>
<li>UDP程序结构较简单；</li>
<li>流模式(<code>Stream</code>)和数据报模式(<code>Dgram</code>)；</li>
<li>TCP保证数据正确性，UDP可能会丢包，TCP保证数据顺序，UDP不保证。</li>
</ol>
<h2 id="TcpClient-TcpListener-UdpClient"><a href="#TcpClient-TcpListener-UdpClient" class="headerlink" title="TcpClient,TcpListener,UdpClient"></a>TcpClient,TcpListener,UdpClient</h2><p>应用程序可以通过<code>TcpClient</code>、<code>TcpListener</code>和<code>UdpClient</code>类使用传输控制协议(TCP)和用户数据文报协议(UDP)服务。这些协议类建立在<code>System.Net.Sockets.Socket</code>类的基础之上，辅助数据传送的细节(也就是说TcpClient、TcpListener和UdpClisent类是用来简化Socket的)。  </p>
<p><code>TcpClient</code>和<code>TcpListener</code>使用<code>NetworkStream</code>类表示网络，使用GetStream方法返回网络流，然后调用该Stream的<code>Read</code>和<code>Write</code>方法。NetworkStream不拥有协议类的基础套接字，因此关闭NetworkStream不影响套接字。  </p>
<p>UdpClient类使用字节数组(byte[])保存UDP数据文报，使用<code>Send</code>方法向网络发送数据，使用<code>Receive</code>方法接收传入的数据文报。</p>
<br>
]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Socket</tag>
      </tags>
  </entry>
  <entry>
    <title>StringBuilder</title>
    <url>/2020/06/13/StringBuilder/</url>
    <content><![CDATA[<h2 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h2><p>StringBuilder类表示可变字符字符串。<br>下面的示例演示如何调用由 StringBuilder 类定义的多个方法：  </p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Text;</span><br><span class="line"></span><br><span class="line">public sealed class App</span><br><span class="line">&#123;</span><br><span class="line">    static void Main()</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; Create a StringBuilder that expects to hold 50 characters.</span><br><span class="line">        &#x2F;&#x2F; Initialize the StringBuilder with &quot;ABC&quot;.</span><br><span class="line">        StringBuilder sb &#x3D; new StringBuilder(&quot;ABC&quot;, 50);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Append three characters (D, E, and F) to the end of the StringBuilder.</span><br><span class="line">        sb.Append(new char[] &#123; &#39;D&#39;, &#39;E&#39;, &#39;F&#39; &#125;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Append a format string to the end of the StringBuilder.</span><br><span class="line">        sb.AppendFormat(&quot;GHI&#123;0&#125;&#123;1&#125;&quot;, &#39;J&#39;, &#39;k&#39;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Display the number of characters in the StringBuilder and its string.</span><br><span class="line">        Console.WriteLine(&quot;&#123;0&#125; chars: &#123;1&#125;&quot;, sb.Length, sb.ToString());</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Insert a string at the beginning of the StringBuilder.</span><br><span class="line">        sb.Insert(0, &quot;Alphabet: &quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Replace all lowercase k&#39;s with uppercase K&#39;s.</span><br><span class="line">        sb.Replace(&#39;k&#39;, &#39;K&#39;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Display the number of characters in the StringBuilder and its string.</span><br><span class="line">        Console.WriteLine(&quot;&#123;0&#125; chars: &#123;1&#125;&quot;, sb.Length, sb.ToString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; This code produces the following output.</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; 11 chars: ABCDEFGHIJk</span><br><span class="line">&#x2F;&#x2F; 21 chars: Alphabet: ABCDEFGHIJK</span><br></pre></td></tr></table></figure>

<h3 id="String-和-StringBuilder-类型"><a href="#String-和-StringBuilder-类型" class="headerlink" title="String 和 StringBuilder 类型"></a>String 和 StringBuilder 类型</h3><p>尽管<code>StringBuilder</code>和<code>String</code>都表示字符序列，但它们的实现方式不同。<code>String</code>是不可变类型。 也就是说，出现用于修改<code>String</code>对象的每个操作实际上会创建一个新字符串。而<code>StringBuilder</code>是一个可变对象，可以预分配缓冲区，这样，往StringBuilder中新增字符时，不会创建新的临时对象。  </p>
<p>对于执行大量字符串操作的例程（如在循环中多次修改字符串的应用程序），重复修改字符串可能会显著降低性能。 替代方法是使用<code>StringBuilder</code>，这是一个<code>可变字符串类</code>。 <u>可变性是指在创建类的实例后，可以通过追加、移除、替换或插入字符来修改它。</u> StringBuilder 对象维护缓冲区以容纳到字符串的扩展。 如果空间可用，则会将新数据追加到缓冲区;否则，将分配一个新的更大的缓冲区，将原始缓冲区中的数据复制到新缓冲区，然后将新数据追加到新缓冲区。</p>
<h3 id="StringBuilder类常用方法"><a href="#StringBuilder类常用方法" class="headerlink" title="StringBuilder类常用方法"></a>StringBuilder类常用方法</h3><ul>
<li>1.Append()方法，给字符串追前添加一个字符或字符串。</li>
<li>2.Insert()方法，在指定的位置插入字符或字符串。<br><code>sb.Insert(0,&#39;a&#39;);  //在索引为0的位置插入字符a</code></li>
<li>3.Remove()方法，从当前字符串中删除字符。<br><code>sb.Remove(0,3);    //删除字符串中给定索引之间的字符</code></li>
<li>4.Replace()方法，用某个字符或字符串替换另一个字符或字符串</li>
<li>5.ToString()方法，用来把当前StringBuilder中存储的字符串，提取成一个不可变的字符串。</li>
</ul>
<h3 id="更多说明"><a href="#更多说明" class="headerlink" title="更多说明"></a>更多说明</h3><p>关于StringBuilder的更多方法、显示接口实现等说明详见微软Docs文档：<a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.text.stringbuilder?view=netcore-3.1#methods" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/api/system.text.stringbuilder?view=netcore-3.1#methods</a></p>
<br>
]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>String Method</title>
    <url>/2020/06/13/StringMethod/</url>
    <content><![CDATA[<h2 id="字符串的一些常用方法"><a href="#字符串的一些常用方法" class="headerlink" title="字符串的一些常用方法"></a>字符串的一些常用方法</h2><a id="more"></a>
<ul>
<li><p>1.ComparaTo()方法，比较字符串的内容。<br>返回一个Int类型值，相同则返回0，不同则返回1。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string name &#x3D; &quot;marc&quot;;</span><br><span class="line">int res &#x3D; name.CompareTo(&quot;lisa&quot;);</span><br><span class="line">Console.Write(res);     &#x2F;&#x2F;1</span><br></pre></td></tr></table></figure>
</li>
<li><p>2.Replace()方法，把指定的字符或字符串换成另一个字符串。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string newStr &#x3D; name.Replace(&quot;rc&quot;,&quot;sa&quot;);</span><br><span class="line">Console.Write(name);        &#x2F;&#x2F;masa</span><br></pre></td></tr></table></figure>
</li>
<li><p>3.Split()方法，在出现给定字符的地方，把字符串拆分成一个字符串数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string[] strArr &#x3D; name.Split(&#39;a&#39;);</span><br><span class="line">foreach (var temp in strArr)</span><br><span class="line">&#123;</span><br><span class="line">    Console.Write(temp + &quot; &quot;);     &#x2F;&#x2F;m rc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>4.Substring()方法，在字符串中检索给定位置的子字符串。<br>Substring(StartIndex, Length)<br>如果参数中没有给定截取长度的话，就会截取字符串里选定字符往后的所有字符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string subStr &#x3D; name.Substring(1,2);    &#x2F;&#x2F;表示从字符串中索引为1的字符处开始截取2个字符</span><br><span class="line">string subStr2 &#x3D; name.Substring(3);     &#x2F;&#x2F;表示从字符串中索引为1的字符处开始截取往后的所有字符</span><br></pre></td></tr></table></figure>
</li>
<li><p>5.ToLower()方法，把字符串转换为小写形式。</p>
</li>
<li><p>6.ToUpper()方法，把字符串转换为大写形式。</p>
</li>
<li><p>7.Trim()方法，删除首尾的空白。<br>常用于用户注册账号的过程中，像玩家注册的用户名首位带有空格的话，就用Trim()方法删掉。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string name2 &#x3D; &quot;  marc  &quot;;</span><br><span class="line">string trimStr &#x3D; name2.Trim();       &#x2F;&#x2F;去除name2的首位空格</span><br></pre></td></tr></table></figure>
</li>
<li><p>8.Concat()方法，合并字符串。</p>
</li>
<li><p>9.CopyTo()方法，把字符串中指定的字符复制到另一个数组中。</p>
</li>
<li><p>10.Format()方法，格式化字符串。</p>
</li>
<li><p>11.IndexOf()方法，取得字符串中第一次出现某个给定字符或字符串的位置。<br>我们可以使用这个方法判断当前字符串是否包含一个给定的子字符串，如包含则返回第一个字符的索引，否则返回-1。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int index &#x3D; name.IndexOf(&quot;rc&quot;);     &#x2F;&#x2F;在name中查找出现子字符串&quot;rc&quot;的索引位置</span><br><span class="line">Console.WriteLine(index);   &#x2F;&#x2F;2</span><br></pre></td></tr></table></figure>

</li>
</ul>
<br>
]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>文字截断在blog里不起作用？</title>
    <url>/2020/05/27/TruncationError/</url>
    <content><![CDATA[<p>有次写好一篇笔记想上传到博客，在本地预览时发现“阅读更多”的标签明明在文中添加了，但是在博客中没起作用。后来经过测试发现标签如果写在了代码块后面，实际预览效果就会出错。  </p>
<a id="more"></a>  

<p><img src="https://s1.ax1x.com/2020/05/27/tAjx00.png" alt="tAjx00.png">  </p>
<p>第一次测试如图，是正常的段落文字加文字截断标签。  </p>
<p><img src="https://s1.ax1x.com/2020/05/27/tAjvmq.png" alt="tAjvmq.png">  </p>
<p>实际预览时就会出错，该截断的文字没有截断，不知道是什么原因，后面的内容也受影响跑到了代码块里···  </p>
<p><img src="https://s1.ax1x.com/2020/05/27/tAjXXn.png" alt="tAjXXn.png">  </p>
<p>第二次测试，将测试部分放在了代码块前。  </p>
<p><img src="https://s1.ax1x.com/2020/05/27/tAjO6s.png" alt="tAjO6s.png">  </p>
<p>这次在博客首页就能看到文字截断起效了，而且文章内容没有受到影响。</p>
<p>待更新···</p>
<p>6月9日更新:<br>generate了一篇blog后，在预览中发现代码块中出现了本不该出现在这个位置的内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Console.Write(&quot;love u 3000 times&quot;);</span><br><span class="line">## 标题</span><br><span class="line">&lt;内容&gt; etc</span><br></pre></td></tr></table></figure>

<p>像这样，起初以为是MarkDown代码块符号用错了，反复测试发现问题是出在“``` ”后的空格，因为MD中空格后回车是起换行的作用，没成想这个习惯给带到输入符号的过程中了，引以为戒。 </p>
<p>之前的有关bolg内容截断失效的原因也是因为代码块符号“``` ”后的空格，而不是截断标签的使用位置。删除空格后即可正常显示。 </p>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>删除排序数组重复项</title>
    <url>/2020/06/14/%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
    <content><![CDATA[<p>LeetCode数据结构练习，通过双指针法来删除排序数组中的重复项。<br><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">LeetCode URL</a></p>
<a id="more"></a>

<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须在原地修改输入数组 并在使用 O(1) 额外空间的条件下完成。  </p>
<pre><code>示例：
给定数组 nums = [1,1,2],   
函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。   
你不需要考虑数组中超出新长度后面的元素。  </code></pre><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>数组完成排序后，我们可以放置两个指针<code>i</code>和<code>j</code>，其中<code>i</code>是慢指针，而<code>j</code>是快指针。只要<code>nums[i] = nums[j]</code>，我们就增加j以跳过重复项。<br>当我们遇到<code>nums[j] != nums[i]</code>时，跳过重复项的运行已经结束，因此我们必须把它（nums[j]）的值复制到<code>nums[i+1]</code>。然后递增<code>i</code>，接着我们将再次重复相同的过程，直到<code>j</code>到达数组的末尾为止。  </p>
<h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><p>快慢指针中的快慢指的是移动的步长，即每次向前移动速度的快慢。例如可以让快指针每次沿链表向前移动2，慢指针每次向前移动1次。<br>快慢指针常用于判断单链表是否存在环、在有序链表中寻找中位数等···（先挖个坑，有机会再填上）</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int RemoveDuplicates(int[] nums) &#123;</span><br><span class="line">        if (nums.Length &#x3D;&#x3D; 0) return 0;</span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line">        for (int j &#x3D; 1; j &lt; nums.Length; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (nums[j] !&#x3D; nums[i])</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">                nums[i] &#x3D; nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return i + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;input: [1,1,2,3,3,3,5]</span><br><span class="line">&#x2F;&#x2F;output： [1,2,3,5]</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>最大子序和</title>
    <url>/2020/06/16/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<pre><code>示例：
输入[-2,1,-3,4,-1,2,1,-5,4]</code></pre><a id="more"></a>

<h2 id="暴力破解法"><a href="#暴力破解法" class="headerlink" title="暴力破解法"></a>暴力破解法</h2><p>通过枚举判断 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int MaxSubArray(int[] nums) &#123;</span><br><span class="line">        int max &#x3D; Int32.MinValue;</span><br><span class="line">        int sum;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; nums.Length; i++)   &#x2F;&#x2F;子序列左端点</span><br><span class="line">        &#123;</span><br><span class="line">            for (int j &#x3D; i; j &lt; nums.Length; j++)   &#x2F;&#x2F;子序列右端点</span><br><span class="line">            &#123;</span><br><span class="line">                sum &#x3D; 0;</span><br><span class="line">                for (int k &#x3D; i; k &lt; j; k++)     &#x2F;&#x2F;暴力计算</span><br><span class="line">                &#123;</span><br><span class="line">                    sum +&#x3D; nums[k];</span><br><span class="line">                    if (sum &gt; max)</span><br><span class="line">                    &#123;</span><br><span class="line">                        max &#x3D; sum;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;intput: [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">&#x2F;&#x2F;output: 6   (leetcode:6)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>Int32.MinValue</code>字段表示Int32的最小可能值。 此字段是常量：<code>public const int MinValue = -2147483648;</code></p>
</blockquote>
<h2 id="改进暴力法"><a href="#改进暴力法" class="headerlink" title="改进暴力法"></a>改进暴力法</h2><p>在上面的代码中可以发现在程序每次执行第二层循环时sum都会清零，所以在我们每次计算子序和时都要重新从i处累加至j,就重复计算了一部分子序和。如果sum不清理，在上一次的序列和基础上来计算新的序列和，就可以减少一层for循环，由O(N^3)变成O(N^2)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int MaxSubArray(int[] nums) &#123;</span><br><span class="line">        int max &#x3D; Int32.MinValue;       &#x2F;&#x2F;定义max值为Integer最小值</span><br><span class="line">        int sum;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; nums.Length; i++)       &#x2F;&#x2F;子序列左端点</span><br><span class="line">        &#123;</span><br><span class="line">            sum &#x3D; 0;</span><br><span class="line">            for (int j &#x3D; i; j &lt; nums.Length; j++)   &#x2F;&#x2F;子序列右端点</span><br><span class="line">            &#123;</span><br><span class="line">                sum +&#x3D; nums[j];     &#x2F;&#x2F;在上一次的序列和基础上来计算新的序列和</span><br><span class="line">                if (sum &gt; max)</span><br><span class="line">                &#123;</span><br><span class="line">                    max &#x3D; sum;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="扫描法"><a href="#扫描法" class="headerlink" title="扫描法"></a>扫描法</h2><blockquote>
<p>（据说这道题是《编程珠机》里面的题目，叫做扫描法，速度最快，扫描一次就求出结果，复杂度是O（n）。书中说，这个算法是一个统计学家提出的，在这略过。）<br>当我们加上一个正数时，和会增加；当我们加上一个负数时，和会减少。如果当前得到的和是个负数，那么这个和在接下来的累加中应该抛弃并重新清零，不然的话这个负数将会减少接下来的和。<br>zwzsdy在他的CSDN博客中有关于该方法的证明和想法，<a href="https://blog.csdn.net/zwzsdy/article/details/80029796" target="_blank" rel="noopener">传送门</a>。  </p>
</blockquote>
<h2 id="动态规划法"><a href="#动态规划法" class="headerlink" title="动态规划法"></a>动态规划法</h2><p>动态规划法也是LeetCode的官方题解方法之一，另一个是分治法。<br>设sum[i]为以第i个元素结尾且和最大的连续子数组。假设对于元素i，所有以它前面的元素结尾的子数组的长度都已经求得，那么以第i个元素结尾且和最大的连续子数组实际上，要么是以第i-1个元素结尾且和最大的连续子数组加上这个元素，要么是只包含第i个元素，即知状态转移方程为：sum[i] = max(sum[i-1] + a[i], a[i])。可以通过判断sum[i-1] + a[i]是否大于a[i]来做选择，而这实际上等价于判断sum[i-1]是否大于0。由于每次运算只需要前一次的结果，因此并不需要像普通的动态规划那样保留之前所有的计算结果，只需要保留上一次的即可，因此算法的时间和空间复杂度都很小。  </p>
<blockquote>
<p>状态转移方程:是动态规划中本阶段的状态往往是上一阶段状态和上一阶段决策的结果。如果给定了第K阶段的状态Sk以及决策uk(Sk)，则第K+1阶段的状态Sk+1也就完全确定。<br>中文名状态转移方程应用学科编程</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int MaxSubArray(int[] nums) &#123;</span><br><span class="line">        int pre &#x3D; 0, maxAns &#x3D; nums[0];</span><br><span class="line">        foreach (int x in nums) &#123;</span><br><span class="line">            pre &#x3D; Math.Max(pre + x, x);</span><br><span class="line">            maxAns &#x3D; Math.Max(maxAns, pre);</span><br><span class="line">        &#125;</span><br><span class="line">        return maxAns;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>栈(Stack)</title>
    <url>/2020/06/21/%E6%A0%88-Stack/</url>
    <content><![CDATA[<h2 id="栈（Stack）"><a href="#栈（Stack）" class="headerlink" title="栈（Stack）"></a>栈（Stack）</h2><p>栈(stack)又叫堆栈，是一种只能在表的一端进行插入和删除操作的线性表。允许进行插入、删除操作的这一端称为栈顶（Top），另一个固定端称为栈底。 </p>
<a id="more"></a>

<p>向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。  </p>
<p>例如栈中有三个元素，近栈的顺序是a1、a2、a3，当需要出栈时顺序为a3,a2,a1,所以栈又称“后进先出”或“先进后出”的线性表，简称“LIFO表”或“FILO表”（Last In First Out）。   </p>
<p><img src="https://s1.ax1x.com/2020/06/21/N3oJ9U.png" alt="N3oJ9U.png"></p>
<h3 id="栈的基本运算（by-CSharp）"><a href="#栈的基本运算（by-CSharp）" class="headerlink" title="栈的基本运算（by CSharp）"></a>栈的基本运算（by CSharp）</h3><h4 id="1-栈初始化"><a href="#1-栈初始化" class="headerlink" title="1.栈初始化"></a>1.栈初始化</h4><pre><code>Stack myStack = new Stack();</code></pre><h4 id="2-判栈空"><a href="#2-判栈空" class="headerlink" title="2.判栈空"></a>2.判栈空</h4><p>直接通过<code>Stack类的Count属性</code>来获取Stack中包含的元素数，以此来判断栈是否为空。  </p>
<pre><code>if (stack.Count == 0)
{
    MessageBox.Show(&quot;堆栈为空&quot;);
}
else
{
    MessageBox.Show(&quot;堆栈不为空&quot;);
}</code></pre><h4 id="3-入栈"><a href="#3-入栈" class="headerlink" title="3.入栈"></a>3.入栈</h4><pre><code>myStack.Push(&quot;A&quot;);</code></pre><h4 id="4-出栈"><a href="#4-出栈" class="headerlink" title="4.出栈"></a>4.出栈</h4><pre><code>Console.WriteLine(&quot;出栈的元素是：{0}&quot;, myStack.Pop());</code></pre><h4 id="5-读栈顶元素"><a href="#5-读栈顶元素" class="headerlink" title="5.读栈顶元素"></a>5.读栈顶元素</h4><pre><code>Console.WriteLine(&quot;栈顶元素：{0}&quot;, myStack.Peek());</code></pre><h4 id="egCode"><a href="#egCode" class="headerlink" title="egCode"></a>egCode</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Stack&lt;string&gt; statck &#x3D; new Stack&lt;string&gt;();</span><br><span class="line">Console.WriteLine(&quot;入栈操作&quot;);</span><br><span class="line">statck.Push(&quot;A&quot;);</span><br><span class="line">statck.Push(&quot;B&quot;);</span><br><span class="line">statck.Push(&quot;C&quot;);</span><br><span class="line">statck.Push(&quot;D&quot;);</span><br><span class="line">foreach (var item in statck)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(item);</span><br><span class="line">&#125;</span><br><span class="line">Console.WriteLine(&quot;出栈操作，元素是：&quot; + statck.Pop());</span><br><span class="line">foreach(var item in statck)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(item);</span><br><span class="line">&#125;</span><br><span class="line">Console.WriteLine(&quot;栈顶元素：&quot; + statck.Peek());</span><br><span class="line">Console.WriteLine(&quot;元素个数：&quot; + statck.Count);</span><br><span class="line">foreach (var item in statck)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(item);</span><br><span class="line">&#125;</span><br><span class="line">Console.WriteLine(&quot;是否包含元素A,true or false: &quot; + statck.Contains(&quot;A&quot;));</span><br></pre></td></tr></table></figure>
<h3 id="栈的存储结构"><a href="#栈的存储结构" class="headerlink" title="栈的存储结构"></a>栈的存储结构</h3><p>由于栈是运算受限的线性表(各个元素依次存放在一组地址连续的存储单元中)，因此线性表的存储结构对栈也是适用的，只是操作不同而已。  </p>
<h4 id="1-顺序栈"><a href="#1-顺序栈" class="headerlink" title="1.顺序栈"></a>1.顺序栈</h4><p>利用顺序存储方式实现的栈称为顺序栈。类似于顺序表的定义，栈中的数据元素用一个预设的足够长度的一维数组来实现，栈底位置可以设置在数组的任意一个端点，而栈顶随着插入和删除而变化。  </p>
<p>通常将0下标端设为栈底，这样空栈时栈顶指标top=-1；入栈时，栈顶指针加1，即s-&gt;top++；出栈时，栈顶指针减1，即s-&gt;top–。栈顶指针与栈中数据元素如下图所示：  </p>
<h4 id="2-链栈"><a href="#2-链栈" class="headerlink" title="2.链栈"></a>2.链栈</h4><p>用链式存储结构实现的栈称为链栈，通过链栈用单链表表示，因此其结点结构与单链表的结点结构相同，但链栈只能在栈顶操作。  </p>
<h5 id="链栈节点类的定义"><a href="#链栈节点类的定义" class="headerlink" title="链栈节点类的定义"></a>链栈节点类的定义</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">namespace DataStructureLearning.ImplementClass</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;链表节点类</span><br><span class="line">    public class LinkNode&lt;T&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        #region ----成员变量-----</span><br><span class="line">        private T data;&#x2F;&#x2F;数据域，当前结点的值</span><br><span class="line">        private LinkNode&lt;T&gt; next;&#x2F;&#x2F;指针域，指向下一个结点</span><br><span class="line">        #endregion</span><br><span class="line">        #region ----构造方法-----</span><br><span class="line">        &#x2F;&#x2F;构造方法</span><br><span class="line">        public LinkNode(T val, LinkNode&lt;T&gt; p)</span><br><span class="line">        &#123;</span><br><span class="line">            data &#x3D; val;</span><br><span class="line">            next &#x3D; p;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;构造方法只包含引用域的结点</span><br><span class="line">        public LinkNode(LinkNode&lt;T&gt; p)</span><br><span class="line">        &#123;</span><br><span class="line">            next &#x3D; p;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;构造方法只包含数据域的结点</span><br><span class="line">        public LinkNode(T val)</span><br><span class="line">        &#123;</span><br><span class="line">            data &#x3D; val;</span><br><span class="line">            next &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;构造方法既不包含数据域也不包含引用域的结点</span><br><span class="line">        public LinkNode()</span><br><span class="line">        &#123;</span><br><span class="line">            data &#x3D; default(T);</span><br><span class="line">            next &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line">        #endregion</span><br><span class="line">        #region ----公有属性-----</span><br><span class="line">        &#x2F;&#x2F;数据域属性</span><br><span class="line">        public T Data</span><br><span class="line">        &#123;</span><br><span class="line">            get</span><br><span class="line">            &#123;</span><br><span class="line">                return data;</span><br><span class="line">            &#125;</span><br><span class="line">            set</span><br><span class="line">            &#123;</span><br><span class="line">                data &#x3D; value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;引用域属性</span><br><span class="line">        public LinkNode&lt;T&gt; Next</span><br><span class="line">        &#123;</span><br><span class="line">            get</span><br><span class="line">            &#123;</span><br><span class="line">                return next;</span><br><span class="line">            &#125;</span><br><span class="line">            set</span><br><span class="line">            &#123;</span><br><span class="line">                next &#x3D; value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        #endregion</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="链栈实体类中几个关键的操作"><a href="#链栈实体类中几个关键的操作" class="headerlink" title="链栈实体类中几个关键的操作"></a>链栈实体类中几个关键的操作</h5><ul>
<li>1.移动链栈的下一节点指针： <code>p=p.Next</code></li>
<li>2.获取节点的数据: <code>p.Data</code></li>
<li>3.空链栈： <code>top==null &amp;&amp; nodeNum==0</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class LinkSeqStack&lt;T&gt;:IStack&lt;T&gt;      &#x2F;&#x2F;继承STL&#x2F;CRL stack对象的结构 IStack</span><br><span class="line">&#123;</span><br><span class="line">    #region 成员变量</span><br><span class="line">    private LinkNode&lt;T&gt; top;&#x2F;&#x2F;栈顶指示器</span><br><span class="line">    private int nodeNum;&#x2F;&#x2F;</span><br><span class="line">    #endregion</span><br><span class="line">    #region 公有属性、索引器</span><br><span class="line">    &#x2F;&#x2F;栈顶指示器属性</span><br><span class="line">    public LinkNode&lt;T&gt; Top</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            return top;</span><br><span class="line">        &#125;</span><br><span class="line">        set</span><br><span class="line">        &#123;</span><br><span class="line">            top &#x3D; value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;元素个数属性</span><br><span class="line">    public int Num</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            return nodeNum;</span><br><span class="line">        &#125;</span><br><span class="line">        set</span><br><span class="line">        &#123;</span><br><span class="line">            nodeNum &#x3D; value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    #endregion</span><br><span class="line">    #region 构造方法</span><br><span class="line">    public LinkSeqStack()</span><br><span class="line">    &#123;</span><br><span class="line">        top &#x3D; null;</span><br><span class="line">        nodeNum &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">    #endregion</span><br><span class="line">    #region 成员方法</span><br><span class="line">    &#x2F;&#x2F;求链栈的长度即nodeNUm</span><br><span class="line">    public int GetLength()</span><br><span class="line">    &#123;</span><br><span class="line">        return nodeNum;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;清空链栈：栈顶指示器置空节且节点数清0</span><br><span class="line">    public void Clear()</span><br><span class="line">    &#123;</span><br><span class="line">        top &#x3D; null;</span><br><span class="line">        nodeNum &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;判断链栈是否为空：如果链栈的栈底指示器为null并且num等于0，则链栈为空，返回true，否则返回false</span><br><span class="line">    public bool IsEmpty()</span><br><span class="line">    &#123;</span><br><span class="line">        if ((top &#x3D;&#x3D; null) &amp;&amp; (nodeNum &#x3D;&#x3D; 0))</span><br><span class="line">        &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;链栈的入栈操作在栈顶添加一个新结点，top指向新的结点，num加1，栈发生变化。</span><br><span class="line">    public void Push(T item)</span><br><span class="line">    &#123;</span><br><span class="line">        LinkNode&lt;T&gt; q &#x3D; new LinkNode&lt;T&gt;(item);</span><br><span class="line">        if (top &#x3D;&#x3D; null)</span><br><span class="line">        &#123;</span><br><span class="line">            top &#x3D; q;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            q.Next &#x3D; top;</span><br><span class="line">            top &#x3D; q;</span><br><span class="line">        &#125;</span><br><span class="line">        ++nodeNum;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;出栈操作是在栈不为空的情况下，先取出栈顶结点的值，然后将栈顶指示器指向栈顶结点的直接后继结点，使之成为新的栈顶结点，num减1</span><br><span class="line">    public T Pop()</span><br><span class="line">    &#123;</span><br><span class="line">        if (IsEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;Stack is empty!&quot;);</span><br><span class="line">            return default(T);</span><br><span class="line">        &#125;</span><br><span class="line">        LinkNode&lt;T&gt; p &#x3D; top;</span><br><span class="line">        top &#x3D; top.Next;</span><br><span class="line">        --nodeNum;</span><br><span class="line">        return p.Data;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;获取链顶结点的值,如果链栈不为空，返回栈顶结点的值，否则返回特殊值表示栈为空，栈不发生变化。</span><br><span class="line">    public T GetTop()</span><br><span class="line">    &#123;</span><br><span class="line">        if (IsEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;Stack is empty!&quot;);</span><br><span class="line">            return default(T);</span><br><span class="line">        &#125;</span><br><span class="line">        return top.Data;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;遍历链栈</span><br><span class="line">    public void ShowItem()</span><br><span class="line">    &#123;</span><br><span class="line">        LinkNode&lt;T&gt; p &#x3D; top;</span><br><span class="line">        while (top !&#x3D; null)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(top.Data + &quot;\t&quot;);</span><br><span class="line">            top &#x3D; top.Next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    #endregion</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p>测试：  </p>
<pre><code>LinkSeqStack&lt;int&gt; lnkstack = new LinkSeqStack&lt;int&gt;();
lnkstack.Push(32);
lnkstack.Push(92);
//stack.Pop();
Console.WriteLine(&quot;遍历链栈:&quot; + &quot;\n&quot;);
lnkstack.ShowItem();</code></pre><br>

<p>参考：<br><a href="https://blog.csdn.net/mingyuli/article/details/82720781" target="_blank" rel="noopener">《数据结构基础—-链栈》明宇</a><br><a href="https://blog.csdn.net/csdn_aiyang/article/details/84941351" target="_blank" rel="noopener">《数据结构与算法-栈和队列》艾阳</a><br><a href="https://blog.csdn.net/CrazyMo_/article/details/46236823" target="_blank" rel="noopener">《C#数据结构回顾之链栈》CrazyMo_</a>  </p>
<br>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2020/06/16/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="Regex类"><a href="#Regex类" class="headerlink" title="Regex类"></a>Regex类</h2><p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.text.regularexpressions.regex?view=netcore-3.1" target="_blank" rel="noopener">Regex类</a>表示<code>.NET Framework</code>的正则表达式引擎（类库），它可用于快速分析大量文本以找到特定的字符模式;提取、编辑、替换或删除文本子字符串;和将提取的字符串添加到集合以生成报告。<br>简单的说，Regex是从字符窗中查找匹配字符串的应用类。通过Regex，编程人员能够非常方便的从一段数据中提取自己所需要的数据信息。</p>
<a id="more"></a>

<h2 id="常用的操作正则表达式的Regex方法"><a href="#常用的操作正则表达式的Regex方法" class="headerlink" title="常用的操作正则表达式的Regex方法"></a>常用的操作正则表达式的Regex方法</h2><ul>
<li>静态方法IsMatch(返回值是一个bool类型，用于判断指定的字符串是否与正则表达式字符串匹配)</li>
<li>静态方法Match</li>
<li>静态方法Matches</li>
<li>Replaces函数</li>
<li>静态方法Split,拆分文本</li>
</ul>
<h2 id="定位元字符"><a href="#定位元字符" class="headerlink" title="定位元字符"></a>定位元字符</h2><blockquote>
<p>@符号，在正则表达式字符串前加上@符号，不让编译器解析其中的转义字符<br>*代表有0个或多个字符</p>
</blockquote>
<p>.   匹配除换行符以外的任意字符<br>\w  匹配字母、数字、下划线、汉字<br>\W  \w的补集<br>\s  匹配任意空白符（包括换行符/n、回车符/r、制表符/t、垂直制表符/v、换页符/f）<br>\S  \s的补集<br>\d  匹配数字（0-9）<br>\D  表示\d的补集（除0-9数字外）<br>\b  匹配单词的开始或结束<br>\B  匹配非单词的开始或结束<br>^  匹配必须出现在字符串的开头或行的开头<br>$  匹配必须出现在以下位置：字符串结尾、字符串结尾处的 \n 之前或行的结尾。   </p>
]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>浅论SDK和API的联系</title>
    <url>/2021/05/03/%E6%B5%85%E8%AE%BASDK%E5%92%8CAPI%E7%9A%84%E8%81%94%E7%B3%BB/</url>
    <content><![CDATA[<h2 id="浅论SDK和API的联系"><a href="#浅论SDK和API的联系" class="headerlink" title="浅论SDK和API的联系"></a>浅论SDK和API的联系</h2><br/>  

<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li><p>SDK是一组工具，用于开发针对特定平台的软件应用程序，其包括工具、库、文档或示例代码。  </p>
</li>
<li><p>API是一种接口，用于软件程序之间进行交互通信。  </p>
</li>
</ul>
<h3 id="差异"><a href="#差异" class="headerlink" title="差异"></a>差异</h3><p>SDK是一套完整的API，可以提供创建应用程序所需的所有部件。而API是一系列相关的接口方法，有时候是针对某个特定的问题提供支持。  </p>
]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title>爬坑-FamilyRacing的那些事</title>
    <url>/2020/10/06/%E7%88%AC%E5%9D%91-FamilyRacing%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    <content><![CDATA[<h2 id="爬坑：FamilyRacing的那些事"><a href="#爬坑：FamilyRacing的那些事" class="headerlink" title="爬坑：FamilyRacing的那些事"></a>爬坑：FamilyRacing的那些事</h2><ul>
<li><p>新建项目WPF初始化过程中，VS报错”无法加载一个或多个请求的类型，有关更多信息，请检索LoaderExceptions属性。”：</p>
<p>这个是微软的机制问题，只要程序集所引用的dll不全或没有引用，就会报出这个错误，根据异常信息在项目bin目录下把缺少的dll文件补全即可。</p>
</li>
<li><p>之前创建项目时直接把其他项目的app.config搬了过来，导致后来添加dll引用时编译器报错 “试图加载格式不正确的程序” ：</p>
<p>一般当项目的目标平台和dll不一致时会出现这个问题，在项目的生成设置里把AnyCPU改成32/64/98即可。</p>
<p>另，引用一个数据库dll的时候，如果平台目标设置不是64位会报错，但是一般情况下AnyCPU是没有问题的。最后发现是创建项目时复制了其他项目的内容在app.config里，导致项目中某些地方生成了一些错误的东西。后来通过重建项目解决了问题，更具体的原因可对比新旧版本项目的csproj文件。</p>
</li>
<li><p>未将对象引用设置到对象的实例：</p>
<p>一般是IOC引用落空了，不是IOC初始化没有引用就是对应类头部没有添加特性，添加上即可。刚接触公司这套东西，经常会忘记添加引用或特性，大部分非代码逻辑的问题都是出在这。</p>
</li>
<li><p>对类型“YDL.UI.LoadSplash.Loading3”的构造函数执行符合指定的绑定约束的调用时引发了异常:</p>
<p>这一块属于程序打包这一块的问题，用dotNetReator对程序进行打包时，如果勾选了“Merge Assemblies”选项，程序打开时就会抛出该异常。</p>
</li>
<li><p>加载大体积文件、文档时，用记事本会打不开，用VSCode可以打开。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>VS</tag>
        <tag>Bug</tag>
      </tags>
  </entry>
  <entry>
    <title>WPF的xaml代码中显示“命名空间不存在对应名称”的错误</title>
    <url>/2020/10/06/%E7%88%AC%E5%9D%91-WPF%E7%9A%84xaml%E4%BB%A3%E7%A0%81%E4%B8%AD%E6%98%BE%E7%A4%BA%E2%80%9C%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%B8%8D%E5%AD%98%E5%9C%A8%E5%AF%B9%E5%BA%94%E5%90%8D%E7%A7%B0%E2%80%9D%E7%9A%84%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<h2 id="爬坑：关于WPF程序的xaml代码处显示“命名空间不存在对应名称”的问题"><a href="#爬坑：关于WPF程序的xaml代码处显示“命名空间不存在对应名称”的问题" class="headerlink" title="爬坑：关于WPF程序的xaml代码处显示“命名空间不存在对应名称”的问题"></a>爬坑：关于WPF程序的xaml代码处显示“命名空间不存在对应名称”的问题</h2><p>背景：在创建一个新的WPF项目时, app.xaml中的DataContext指向了一个IOC初始化类，但是“IOCInit.cs”在项目中已经存在，编译器却提示：命名空间不存在对应名称。</p>
<a id="more"></a>

<p>不知道是什么玄学，网上也没有找到具体的原因，但是都一致给出了相似的解决方法：</p>
<ul>
<li>在Debug下生成时说命名空间中找不到我自定义的控件。此时切换到Release模式，再生成。生成成功后切换回Debug模式就不报错了。这是Release模式下找不到我们自定义的控件导致的报错。所以切换为Release后生成则可以解决此问题。</li>
<li>同是xaml里显示“命名空间不存在对应名称”的问题，在项目属性里配置Debug/Release不是任何时候都奏效的，这时候可以根据警告信息检查程序集版本有无问题，如果程序集版本落后，在项目属性里调整版本然后编译即可解决问题。</li>
</ul>
]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>VS</tag>
        <tag>Bug</tag>
        <tag>WPF</tag>
        <tag>XAML</tag>
      </tags>
  </entry>
  <entry>
    <title>爬坑-关于“未能加载文件或程序集”的解决方法</title>
    <url>/2020/09/28/%E7%88%AC%E5%9D%91-%E5%85%B3%E4%BA%8E%E2%80%9C%E6%9C%AA%E8%83%BD%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6%E6%88%96%E7%A8%8B%E5%BA%8F%E9%9B%86%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E6%B3%95/</url>
    <content><![CDATA[<h2 id="爬坑：关于“未能加载文件或程序集”的解决方法"><a href="#爬坑：关于“未能加载文件或程序集”的解决方法" class="headerlink" title="爬坑：关于“未能加载文件或程序集”的解决方法"></a>爬坑：关于“未能加载文件或程序集”的解决方法</h2><p>调试项目时重写了2个类，上一个版本可以正常运行，但是重写后一跑立马报了一个异常“EntryAssembly: D:\VR\Egg_Unmannad.exe UnhandledException: Ioc instance init erro!!”</p>
<a id="more"></a>

<h3 id="异常信息："><a href="#异常信息：" class="headerlink" title="异常信息："></a>异常信息：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EntryAssembly: D:\VR\Egg_Unmannad.exe</span><br><span class="line">UnhandledException:</span><br><span class="line">Ioc instance init erro!!</span><br><span class="line">StackTrace:</span><br><span class="line">   在 YDL.YDLVRInitializer.InitIoc(String ioc) 位置 E:\VSProject\YDLSystem2\src\YDL\YDL.Core\YDLVRInitializer.cs:行号 66</span><br><span class="line">  在 YDL.YDLVRInitializer.InitNormal(Action&#96;1 showMsg) 位置 E:\VSProject\YDLSystem2\src\YDL\YDL.Core\YDLVRInitializer.cs:行号 105</span><br><span class="line">  在 YDL.WPF.Notify.InitModelBase.&lt;&gt;c.&lt;CMD_Loaded&gt;b__14_0() 位置 E:\VSProject\YDLSystem2\src\YDL\YDL.Core\WPF\Notify\InitModelBase.cs:行号 73</span><br><span class="line">  在 System.Threading.Tasks.Task.InnerInvoke()</span><br><span class="line">  在 System.Threading.Tasks.Task.Execute()</span><br><span class="line">--- 引发异常的上一位置中堆栈跟踪的末尾 ---</span><br><span class="line">  在 System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)</span><br><span class="line">  在 System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)</span><br><span class="line">  在 System.Runtime.CompilerServices.TaskAwaiter.GetResult()</span><br><span class="line">  在 YDL.WPF.Notify.InitModelBase.&lt;CMD_Loaded&gt;d__14.MoveNext() 位置 E:\VSProject\YDLSystem2\src\YDL\YDL.Core\WPF\Notify\InitModelBase.cs:行号 73</span><br><span class="line">--- 引发异常的上一位置中堆栈跟踪的末尾 ---</span><br><span class="line">  在 System.Runtime.CompilerServices.AsyncMethodBuilderCore.&lt;&gt;c.&lt;ThrowAsync&gt;b__6_0(Object state)</span><br><span class="line">  在 System.Windows.Threading.ExceptionWrapper.InternalRealCall(Delegate callback, Object args, Int32 numArgs)</span><br><span class="line">  在 System.Windows.Threading.ExceptionWrapper.TryCatchWhen(Object source, Delegate callback, Object args, Int32 numArgs, Delegate catchHandler)</span><br></pre></td></tr></table></figure>

<br/>

<h3 id="控制台输出信息："><a href="#控制台输出信息：" class="headerlink" title="控制台输出信息："></a>控制台输出信息：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">主屏幕边界 &#123;X&#x3D;0,Y&#x3D;0,Width&#x3D;1920,Height&#x3D;1080&#125;</span><br><span class="line">初始化0%</span><br><span class="line">无法加载程序集YDL.IOC, Version&#x3D;1.0.0.0, Culture&#x3D;neutral, PublicKeyToken&#x3D;null - 未能加载文件或程序集“YDL.IOC, Version&#x3D;1.0.0.0, Culture&#x3D;neutral, PublicKeyToken&#x3D;null”或它的某一个依赖项。系统找不到指定的文件。</span><br><span class="line">无法加载程序集YDL.Log, Version&#x3D;1.0.0.0, Culture&#x3D;neutral, PublicKeyToken&#x3D;null - 未能加载文件或程序集“YDL.Log, Version&#x3D;1.0.0.0, Culture&#x3D;neutral, PublicKeyToken&#x3D;null”或它的某一个依赖项。系统找不到指定的文件。</span><br><span class="line">无法加载程序集YDL.SQL, Version&#x3D;1.0.0.0, Culture&#x3D;neutral, PublicKeyToken&#x3D;null - 未能加载文件或程序集“YDL.SQL, Version&#x3D;1.0.0.0, Culture&#x3D;neutral, PublicKeyToken&#x3D;null”或它的某一个依赖项。系统找不到指定的文件。</span><br><span class="line">无法加载程序集YDL.VR.Core, Version&#x3D;1.0.0.0, Culture&#x3D;neutral, PublicKeyToken&#x3D;null - 未能加载文件或程序集“YDL.VR.Core, Version&#x3D;1.0.0.0, Culture&#x3D;neutral, PublicKeyToken&#x3D;null”或它的某一个依赖项。系统找不到指定的文件。</span><br><span class="line">无法加载程序集YDL.Dog, Version&#x3D;1.0.0.0, Culture&#x3D;neutral, PublicKeyToken&#x3D;null - 未能加载文件或程序集“YDL.Dog, Version&#x3D;1.0.0.0, Culture&#x3D;neutral, PublicKeyToken&#x3D;null”或它的某一个依赖项。系统找不到指定的文件。</span><br><span class="line">无法加载程序集YDL.LiveBroadcast, Version&#x3D;1.0.0.0, Culture&#x3D;neutral, PublicKeyToken&#x3D;null - 未能加载文件或程序集“YDL.LiveBroadcast, Version&#x3D;1.0.0.0, Culture&#x3D;neutral, PublicKeyToken&#x3D;null”或它的某一个依赖项。系统找不到指定的文件。 &#x2F;&#x2F;Missing</span><br><span class="line">无法加载程序集YDL.MotoPlatform, Version&#x3D;1.0.0.0, Culture&#x3D;neutral, PublicKeyToken&#x3D;null - 未能加载文件或程序集“YDL.MotoPlatform, Version&#x3D;1.0.0.0, Culture&#x3D;neutral, PublicKeyToken&#x3D;null”或它的某一个依赖项。系统找不到指定的文件。 &#x2F;&#x2F;Missing</span><br></pre></td></tr></table></figure>

<p><img src="https://s1.ax1x.com/2020/08/18/dKXu3F.png" alt="dKXu3F.png"></p>
<p>后来发现是在项目的引用中<code>没有添加对应的引用</code>，即YDL.LiveBroadcast和YDL.MotoPlatform，添加后就可以正常运行了。</p>
<p><img src="https://s1.ax1x.com/2020/08/18/dKXn9U.png" alt="dKXn9U.png"></p>
<p>（话说没有找到项目Config配置文件里是在哪声明的dll版本, 先挖个坑， 有机会再填上。）</p>
<br/>

<p>[参考]{<a href="https://blog.csdn.net/lwpoor123/article/details/78350212}" target="_blank" rel="noopener">https://blog.csdn.net/lwpoor123/article/details/78350212}</a></p>
]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>VS</tag>
        <tag>Bug</tag>
      </tags>
  </entry>
  <entry>
    <title>爬坑-关于程序跨区域使用时小数点转换成逗号的问题</title>
    <url>/2021/06/15/%E7%88%AC%E5%9D%91-%E5%85%B3%E4%BA%8E%E7%A8%8B%E5%BA%8F%E8%B7%A8%E5%8C%BA%E5%9F%9F%E4%BD%BF%E7%94%A8%E6%97%B6%E5%B0%8F%E6%95%B0%E7%82%B9%E8%BD%AC%E6%8D%A2%E6%88%90%E9%80%97%E5%8F%B7%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>手头有项目需要和外企业合作开发，其中涉及到一个协议对接的问题，虽然两边的开发团队事先都有协商好统一的开发协议，但是在收发命令时，发现国外Double转换会把小数点转换为逗号。<br>这种情况在中文操作系统下没有出现，反而是在英文操作系统下出现了，两边的人还反复确认了几遍、都觉得自己没有问题。最后通过<code>修改区域性</code>为英文解决。  </p>
<a id="more"></a>

<p>App.xaml:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Application</span> <span class="attr">x:Class</span>=<span class="string">"测试工具.App"</span></span></span><br><span class="line"><span class="tag">             <span class="attr">xmlns</span>=<span class="string">"http://schemas.microsoft.com/winfx/2006/xaml/presentation"</span></span></span><br><span class="line"><span class="tag">             <span class="attr">xmlns:x</span>=<span class="string">"http://schemas.microsoft.com/winfx/2006/xaml"</span></span></span><br><span class="line"><span class="tag">             <span class="attr">xmlns:local</span>=<span class="string">"clr-namespace:测试工具"</span></span></span><br><span class="line"><span class="tag">             <span class="attr">StartupUri</span>=<span class="string">"MainWindow.xaml"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Application.Resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ResourceDictionary</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ResourceDictionary.MergedDictionaries</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 设置区域性为英文 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ResourceDictionary</span> <span class="attr">Source</span>=<span class="string">"StringResource.en-US.xaml"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">ResourceDictionary.MergedDictionaries</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ResourceDictionary</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Application.Resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Application</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>像这种情况可以通过以下三种方法解决：  </p>
<ol>
<li><p>转换的数字格式为“3.3”，转换后出来aa为“3，3”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CultureInfo ci &#x3D; (CultureInfo)CultureInfo.CurrentCulture.Clone();</span><br><span class="line">ci.NumberFormat.CurrentDecimalSeparator &#x3D; &quot;.&quot;;</span><br><span class="line">float aa &#x3D; float.Parsse(this.textBox1.Text.Trim(), NumberStyles.Any, ci);</span><br></pre></td></tr></table></figure>
</li>
<li><p>工程Program.cs中增加这行代码，通过CurrentCulture把线程区域性设置为中文。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;设置区域性，其他语言同理，如&quot;en-US&quot;</span><br><span class="line">Thread.CurrentThread.CurrentCulture &#x3D; new System.Globalization.CultureInfo(&quot;zh-CN&quot;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>亦或是在App.xmal中修改区域性，和开篇的那行代码一样。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ResourceDictionary</span> <span class="attr">Source</span>=<span class="string">"StringResource.en-US.xaml"</span> /&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>参考：<br>&lt;区域性问题导致多语言软件允许出错&gt; yueqing</p>
]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Bug</tag>
      </tags>
  </entry>
  <entry>
    <title>爬坑-显示器标识号与屏幕区域不匹配的问题</title>
    <url>/2020/10/10/%E7%88%AC%E5%9D%91-%E6%98%BE%E7%A4%BA%E5%99%A8%E6%A0%87%E8%AF%86%E5%8F%B7%E4%B8%8E%E5%B1%8F%E5%B9%95%E5%8C%BA%E5%9F%9F%E4%B8%8D%E5%8C%B9%E9%85%8D%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="爬坑：关于显示器标识号与屏幕区域不匹配的问题"><a href="#爬坑：关于显示器标识号与屏幕区域不匹配的问题" class="headerlink" title="爬坑：关于显示器标识号与屏幕区域不匹配的问题"></a>爬坑：关于显示器标识号与屏幕区域不匹配的问题</h2><p>最近有个项目需求，要求在计算机有多个显示屏幕的环境下，把指定的应用程序显示在指定的显示器上。</p>
<p>起初的要求是把应用程序弹到“最后一块”屏幕上即可，比如横向排列的3块显示器，屏幕标识号（桌面右键-显示设置）依次为1\2\3，那目标屏幕就是3号屏。</p>
<a id="more"></a>

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201010203717382.png" alt="image-20201010203717382" style="zoom: 50%;" />

<p>那就做呗，然后在项目的加载事件里添加了几行代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void ShowToLastSc(int count)</span><br><span class="line">&#123;</span><br><span class="line">    Screen[] sc;</span><br><span class="line">    sc &#x3D; Screen.AllScreens;</span><br><span class="line"></span><br><span class="line">    this.StartPosition &#x3D; FormStartPosition.Manual;</span><br><span class="line">    &#x2F;&#x2F;this.Location &#x3D; new Point(sc[count].Bounds.Left, sc[count].Bounds.Top);</span><br><span class="line">    this.Left &#x3D; sc[count].Bounds.Left;</span><br><span class="line">    this.Top &#x3D; sc[count].Bounds.Top;</span><br><span class="line">    this.Width &#x3D; sc[count].Bounds.Width;</span><br><span class="line">    this.Height &#x3D; sc[count].Bounds.Height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行后发现效果不对，原本该显示在最后一块屏幕的窗口显示在了1号屏。</p>
]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Bug</tag>
        <tag>计算机硬件</tag>
      </tags>
  </entry>
  <entry>
    <title>线程PlatformNotSupportedException异常</title>
    <url>/2020/06/21/%E7%BA%BF%E7%A8%8BPlatformNotSupportedException%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h2 id="System-PlatformNotSupportedException-”Operation-is-not-supported-on-this-platform”"><a href="#System-PlatformNotSupportedException-”Operation-is-not-supported-on-this-platform”" class="headerlink" title="System.PlatformNotSupportedException:”Operation is not supported on this platform”"></a>System.PlatformNotSupportedException:”Operation is not supported on this platform”</h2><p>详细信息：  </p>
<pre><code>System.PlatformNotSupportedException
HResult=0x80131539
Message=Operation is not supported on this platform.
Source=System.Private.CoreLib
StackTrace:
at System.Func`3.BeginInvoke(T1 arg1, T2 arg2, AsyncCallback callback, Object object)
at _010_线程.Program.Main(String[] args) in D:\VSProject\CSharpStudy\Level3\CSStudy3\010-线程\Program.cs:line 13</code></pre><a id="more"></a>

<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>在vs2019创建.NET Core(3.1.301)的控制台应用程序，执行以下代码： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;&#x2F;&#x2F;Action a &#x3D; Test;</span><br><span class="line">        Func&lt;int, string, int&gt; a &#x3D; Test;        &#x2F;&#x2F;通过委托开起一个线程    </span><br><span class="line">        IAsyncResult ar &#x3D; a.BeginInvoke(100, &quot;siki&quot;, null, null);      &#x2F;&#x2F;run报错：平台不支持该操作</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(&quot;Main&quot;);</span><br><span class="line">        while (ar.IsCompleted &#x3D;&#x3D; false)     &#x2F;&#x2F;如果当前线程没有执行完毕</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&#39;.&#39;);</span><br><span class="line">            Thread.Sleep(100);      &#x2F;&#x2F;让Main线程休眠100ms</span><br><span class="line">        &#125;</span><br><span class="line">        int res &#x3D; a.EndInvoke(ar);      &#x2F;&#x2F;取得异步线程a的返回值ar</span><br><span class="line">        Console.WriteLine(res);</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    static int Test(int i, string str)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;test&quot; + i + str);</span><br><span class="line">        Thread.Sleep(100);          &#x2F;&#x2F;让当前线程休眠100ms</span><br><span class="line">        return 100;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s1.ax1x.com/2020/06/21/N35WxH.png" alt="N35WxH.png"></p>
<p>运行前代码中没有出现编译错误，但是在运行后在“IAsyncResult ar = a.BeginInvoke(100, “siki”, null, null);”处会返回一个异常：System.PlatformNotSupportedException 。  </p>
<p>上网找了下相关异常的处理方式，最后参考了<a href="https://www.cnblogs.com/Zev_Fung/" target="_blank" rel="noopener">阿水zev</a>的一篇博客。 <a href="https://www.cnblogs.com/Zev_Fung/p/12823418.html" target="_blank" rel="noopener">(传送门)</a>    </p>
<p>阿水例子中使用APM的线程代码运行后会出现同样的错误：  </p>
<p><img src="https://s1.ax1x.com/2020/06/21/N35hMd.png" alt="N35hMd.png"></p>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>异步编程模型(APM)(使用IAsyncResult和BeginInvoke)不再是异步调用的优选方法。从.NET Framework 4.5开始，基于任务的异步模式(TAP)是推荐的异步模型。因此，而且由于异步委托的实现取决于远程处理但.NET Core不存在的功能，BeginInvoke和EndInvoke委托调用不.NET Core支持。（GitHub问题 <a href="https://github.com/dotnet/runtime/issues/16312" target="_blank" rel="noopener">dotnet/corefx＃5940</a> 中对此进行了讨论）</p>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>后来直接就在阿水的例子上实验Task.Run了，自己的代码越改越多bug···<br>改为基于任务的异步模式Task.Run  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public delegate string AsyncMethodCaller(int callDuration, out int threadId);</span><br><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;基于任务的异步模式(TAP)</span><br><span class="line">        AsyncMethodCaller caller &#x3D; new AsyncMethodCaller(TestMethodAsync);</span><br><span class="line">        int threadid &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F;开启异步操作 IAsyncResult BeginInvoke</span><br><span class="line">        var workTask &#x3D; Task.Run(() &#x3D;&gt; caller.Invoke(3000, out threadid));</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;其他业务&quot; + i.ToString());</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;调用EndInvoke，等待异步执行完成</span><br><span class="line">        Console.WriteLine(&quot;等待异步方法TestMethodAsync执行完成&quot;);</span><br><span class="line">        string res &#x3D; workTask.Result;</span><br><span class="line">        Console.WriteLine(&quot;Compeleted!&quot;);</span><br><span class="line">        Console.WriteLine(res);</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;基于任务的异步模式(TAP)</span><br><span class="line">    static string TestMethodAsync(int callDuration, out int threadId)</span><br><span class="line">    &#123;</span><br><span class="line">        Stopwatch sw &#x3D; new Stopwatch(); &#x2F;&#x2F;创建一个Stopwatch对象 用来测量运行时间</span><br><span class="line">        sw.Start();     &#x2F;&#x2F;开始测量运行时间</span><br><span class="line">        Console.WriteLine(&quot;异步TestMethodAsync开始&quot;);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 5; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F;模拟耗时操作</span><br><span class="line">            Thread.Sleep(callDuration);</span><br><span class="line">            Console.WriteLine(&quot;TestMethodAsync:&quot; + i.ToString());</span><br><span class="line">        &#125;</span><br><span class="line">        sw.Stop();      &#x2F;&#x2F;停止策略运行时间</span><br><span class="line">        threadId &#x3D; Thread.CurrentThread.ManagedThreadId;    &#x2F;&#x2F;获取当前线程，获取该线程是否属于托管线程池的值</span><br><span class="line">        return string.Format(&quot;耗时&#123;0&#125;ms.&quot;, sw.ElapsedMilliseconds.ToString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://s1.ax1x.com/2020/06/21/N35RRe.png" alt="N35RRe.png"></p>
<br>










]]></content>
      <categories>
        <category>C#</category>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Bug</tag>
      </tags>
  </entry>
  <entry>
    <title>线程调用带参数方法</title>
    <url>/2020/06/21/%E7%BA%BF%E7%A8%8B%E8%B0%83%E7%94%A8%E5%B8%A6%E5%8F%82%E6%95%B0%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="通过Thread发起线程时怎么调用带参数的方法"><a href="#通过Thread发起线程时怎么调用带参数的方法" class="headerlink" title="通过Thread发起线程时怎么调用带参数的方法"></a>通过Thread发起线程时怎么调用带参数的方法</h2><p>在.NET Framework中可以通过2种方法实现线程调用带参数的方法:Thread.Start(object),封装线程的方法和参数</p>
<a id="more"></a>

<h3 id="第一种：通过-Thread-Start-object-方法"><a href="#第一种：通过-Thread-Start-object-方法" class="headerlink" title="第一种：通过 Thread.Start(object) 方法"></a>第一种：通过 Thread.Start(object) 方法</h3><p><code>Start(object)</code> 指导致操作系统将当前实例的状态更改为 Running，并选择提供包含线程执行的方法要使用的数据的对象。  </p>
<pre><code>public void Start (object parameter);</code></pre><blockquote>
<p><code>Object Data type</code> 保存引用对象的地址， 可以将任何引用类型（字符串、数组、类或接口）分配给 Object 变量， Object变量还可以引用任意值类型的数据（数值、、 Boolean Char 、 Date 、结构或枚举）。 Object数据类型可以指向任何数据类型的数据，包括应用程序识别的任何对象实例。 在 Object 编译时不知道变量可能指向的数据类型时，请使用。</p>
</blockquote>
<p>在线程(函数)的参数位置定义一个object数据类型参数，在运行线程时通过调用Thread类方法Start(object)来传递参数。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">    static void DownloadFile(object filename)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;开始下载&quot;);</span><br><span class="line">        Thread.Sleep(1000);     &#x2F;&#x2F;让线程休眠1000ms</span><br><span class="line">        Console.WriteLine(&quot;下载完成&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">            static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Thread t &#x3D; new Thread(DownloadFile);    &#x2F;&#x2F;初始化Therad类的新实例 Downloadfile</span><br><span class="line">        t.Start(&quot;xxx种子&quot;);                     &#x2F;&#x2F;让t线程开始运行   传递object类参数filename string</span><br><span class="line">        &#x2F;&#x2F;t.Start(&#39;y&#39;);                         &#x2F;&#x2F;让t线程开始运行   传递object类参数filename char</span><br><span class="line">        &#x2F;&#x2F;t.Start(666);                         &#x2F;&#x2F;让t线程开始运行   传递object类参数filename int</span><br><span class="line">        Console.WriteLine(&quot;Main&quot;);</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第二种：封装线程的方法和参数"><a href="#第二种：封装线程的方法和参数" class="headerlink" title="第二种：封装线程的方法和参数"></a>第二种：封装线程的方法和参数</h3><p>单独创建一个Thread类，将线程执行的方法和参数都封装到一个类里面，通过实例化该类，方法就可以调用属性来实现间接的类型安全地传递参数。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MyThread</span><br><span class="line">&#123;</span><br><span class="line">    private string filename;</span><br><span class="line">    private string filepath;</span><br><span class="line"></span><br><span class="line">    public MyThread(string fileName, string filePath)</span><br><span class="line">    &#123;</span><br><span class="line">        this.filename &#x3D; fileName;</span><br><span class="line">        this.filepath &#x3D; filePath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void DownFile()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;开始下载&quot; + filepath + filename);</span><br><span class="line">        Thread.Sleep(1000);</span><br><span class="line">        Console.WriteLine(&quot;下载完成&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;通过单独创建一个Thread类来传递参数</span><br><span class="line">        MyThread my &#x3D; new MyThread(&quot;xxx.bt&quot;, &quot;http:&#x2F;&#x2F;xxxx.com&quot;);</span><br><span class="line">        Thread t &#x3D; new Thread(my.DownFile);     &#x2F;&#x2F;new 一个Thread对象，传递my的DowanFile方法</span><br><span class="line">        t.Start();</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行效果:<br><a href="https://imgchr.com/i/N3IrlQ" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/06/21/N3IrlQ.png" alt="N3IrlQ.png"></a></p>
<br>]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>语言继承查询(LINQ)</title>
    <url>/2020/06/21/%E8%AF%AD%E8%A8%80%E7%BB%A7%E6%89%BF%E6%9F%A5%E8%AF%A2-LINQ/</url>
    <content><![CDATA[<h2 id="语言继承查询-LINQ"><a href="#语言继承查询-LINQ" class="headerlink" title="语言继承查询 (LINQ)"></a>语言继承查询 (LINQ)</h2><p>语言集成查询 (LINQ) 是一系列直接将查询功能集成到 C# 语言的技术统称，是.<code>NET Frameorek 3.5</code> 的新增特性。<br>借助LINQ，可以使用语言关键字和熟悉的运算符针对强类型化对象集合编写查询，通俗一点说就是是指将查询功能和语言结合起来，从而为我们提供一种统一的方式，让我们能在C#或VB.NET语言中直接查询和操作各种数据。</p>
<a id="more"></a>

<p>通过LINQ查询表达式中的查询语法可以用最少的代码对数据源执行筛选、排序和分组操作。 可使用相同的基本查询表达式模式来查询和转换 SQL 数据库、ADO .NET 数据集、XML 文档和流以及 .NET 集合中的数据。</p>
<blockquote>
<p>在LINQ之前，数据查询历来都表示为简单的字符串，没有编译时类型检查或 IntelliSense 支持。 此外，需要针对每种类型的数据源了解不同的查询语言：SQL 数据库、XML 文档、各种 Web 服务等。</p>
</blockquote>
<h3 id="数据单元"><a href="#数据单元" class="headerlink" title="数据单元"></a>数据单元</h3><p>LINQ中最基本的数据单元是<code>sequences</code>和<code>elements</code>。一个sequence是实现了<code>IEnumerable&lt;T&gt;</code>的对象，而一个element是sequence中的每一个元素。如下，names就是一个sequence，”Tom”，“Dick”和”Harry”则是elements。<br>    string[] names = {“Tom”, “Dick”, “Harry”};</p>
<p>一个<code>查询运算符</code>就是用来转换sequence的方法。  </p>
<p>LINQ共有两组标准查询运算符，一组作用于接口<code>IEnumerable&lt;T&gt;</code>的对象，另一组作用于接口<code>IQueryable&lt;T&gt;</code>的对象。  </p>
<p>而接口<code>IEnumerable&lt;T&gt;</code>的方法返回的可枚举对象将捕获传递到方法的参数，在枚举该对象时，将使用查询运算符的逻辑，并返回查询结果。  </p>
<p>与之相反，接口<code>IQueryable&lt;T&gt;</code>的方法不会实现任何查询行为，但会生成一个表示要执行的查询的表达式树。  </p>
<p>所以一个典型的查询运算符在接收一个输入sequence后会输出一个转换之后的sequence。  </p>
<h4 id="egCode"><a href="#egCode" class="headerlink" title="egCode"></a>egCode</h4><pre><code>string[] names = { &quot;Tom&quot;, &quot;Dick&quot;, &quot;Harry&quot;   };

// 获取所有长度大于等于4的名字
IEnumerable&lt;string&gt; filteredNames = System.Linq.Enumerable.Where(
    names, n =&gt; n.Length &gt;= 4);     //直接在names对象上调用Where

foreach (string n in filteredNames)
    Console.WriteLine(n);</code></pre><p>Tip:可以通过创建一个变量来简化query<br>    [datatype] (variable name) = (sequences name).Where(lambda expression);</p>
<p>就以面的例子，我们可以通过使用var关键字来进一步简写我们的query：<br>    var filteredNames = names.Where(n =&gt; n.Length &gt;= 4);<br>但是这样会影响可读性，最好是使用确切的返回值类型。  </p>
<p>下面的query获取所有包含字母a的名字：  </p>
<pre><code>string[] names = { &quot;Tom&quot;, &quot;Dick&quot;, &quot;Harry&quot; };
IEnumerable&lt;string&gt; filteredNames = names.Where(n =&gt; n.Contains(&quot;a&quot;));

foreach (string name in filteredNames)
Console.WriteLine(name);    // Harry</code></pre><p>LINQ 查询变量被类型化为 IEnumerable<T> 或派生类型（如 IQueryable<T>）。 看到类型化为 IEnumerable<Customer> 的查询变量时，就意味着执行查询时，该查询将生成包含零个或多个 Customer 对象的序列。  </p>
<h3 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h3><p>完整的查询操作应该包括创建数据源、定义查询表达式和在foreach语句中执行查询。  </p>
<p>例如：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class LINQQueryExpressions</span><br><span class="line">&#123;</span><br><span class="line">    static void Main()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Specify the data source.</span><br><span class="line">        int[] scores &#x3D; new int[] &#123; 97, 92, 81, 60 &#125;;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Define the query expression.</span><br><span class="line">        IEnumerable&lt;int&gt; scoreQuery &#x3D;</span><br><span class="line">            from score in scores</span><br><span class="line">            where score &gt; 80</span><br><span class="line">            select score;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Execute the query.</span><br><span class="line">        foreach (int i in scoreQuery)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(i + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Output: 97 92 81</span><br></pre></td></tr></table></figure>

<blockquote>
<p>查询表达式必须以 from 子句开头，且必须以 select 或 group 子句结尾。 在第一个 from 子句与最后一个 select 或 group 子句之间，可以包含以下这些可选子句中的一个或多个：where、orderby、join、let，甚至是其他 from 子句。 还可以使用 into 关键字，使 join 或 group 子句的结果可以充当相同查询表达式中的其他查询子句的源。</p>
</blockquote>
<br>

<p>参考：<br><a href="https://docs.microsoft.com/" target="_blank" rel="noopener">微软doc文档</a><br><a href="https://www.cnblogs.com/lifepoem/archive/2011/10/25/2223765.html" target="_blank" rel="noopener">LINQ之路-柯尊龙</a>  </p>
<br>]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
</search>
